// Generated by CoffeeScript 2.3.1
// Import
var TaskGroup, balUtilFlow, eachr, typeChecker;

({TaskGroup} = require('taskgroup'));

typeChecker = require('typechecker');

eachr = require('eachr');

// =====================================
// Flow
balUtilFlow = {
  // Wait a certain amount of milliseconds before firing the function
  wait: function(delay, fn) {
    return setTimeout(fn, delay);
  },
  // Flow through a series of actions on an object
  // next(err)
  flow: function(...args) {
    var action, actions, next, object, tasks;
    // Extract
    if (args.length === 1) {
      ({object, actions, action, args, tasks, next} = args[0]);
    } else if (args.length === 4) {
      [object, action, args, next] = args;
    } else if (args.length === 3) {
      [actions, args, next] = args;
    }
    // Check
    if ((action != null) === false && (actions != null) === false) {
      throw new Error('balUtilFlow.flow called without any action');
    }
    // Create tasks group and cycle through it
    if (actions == null) {
      actions = action.split(/[,\s]+/g);
    }
    if (object == null) {
      object = null;
    }
    tasks || (tasks = new TaskGroup().done(next));
    actions.forEach(function(action) {
      return tasks.addTask(function(complete) {
        var argsClone, fn;
        // Prepare callback
        argsClone = (args || []).slice();
        argsClone.push(complete);
        // Fire the action with the next helper
        fn = typeChecker.isFunction(action) ? action : object[action];
        return fn.apply(object, argsClone);
      });
    });
    // Fire the tasks synchronously
    tasks.run();
    return this;
  },
  // Create snore
  createSnore: function(message, opts) {
    var snore;
    // Prepare
    opts || (opts = {});
    if (opts.delay == null) {
      opts.delay = 5000;
    }
    // Create snore object
    snore = {
      snoring: false,
      timer: setTimeout(function() {
        snore.clear();
        snore.snoring = true;
        return typeof message === "function" ? message() : void 0;
      }, opts.delay),
      clear: function() {
        if (snore.timer) {
          clearTimeout(snore.timer);
          return snore.timer = false;
        }
      }
    };
    // Return
    return snore;
  },
  // Suffix an array
  suffixArray: function(suffix, ...args) {
    var arg, i, item, j, len, len1, result;
    result = [];
    for (i = 0, len = args.length; i < len; i++) {
      arg = args[i];
      if (!typeChecker.isArray(arg)) {
        arg = [arg];
      }
      for (j = 0, len1 = arg.length; j < len1; j++) {
        item = arg[j];
        result.push(item + suffix);
      }
    }
    return result;
  }
};

// =====================================
// Export
module.exports = balUtilFlow;
