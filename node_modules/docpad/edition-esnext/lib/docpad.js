// Generated by CoffeeScript 2.5.1
  //#*
  // The central module for DocPad
  // @module DocPad
  //#

// =====================================
  // Requires

// Standard
  /**
   * Contains methods for managing the DocPad application.
   * Extends https://github.com/bevry/event-emitter-grouped
   *
   * You can use it like so:
   *
   * 	new DocPad(docpadConfig, function(err, docpad) {
   * 		if (err) return docpad.fatal(err)
   * 		return docpad.action(action, function(err) {
   * 			if (err) return docpad.fatal(err)
   * 			return console.log('OK')
   * 		})
   * 	})
   *
   * @class Docpad
   * @constructor
   * @extends EventEmitterGrouped
   */
var BasePlugin, CSON, Collection, DocPad, DocumentModel, ElementsCollection, Errlop, EventEmitterGrouped, Events, FileModel, FilesCollection, Filter, Human, Logger, MetaCollection, Model, PluginLoader, Progress, QueryCollection, ScriptsCollection, StylesCollection, TaskGroup, ambi, ansiStyles, balUtil, docpadUtil, eachr, envFile, extendr, extractOptsAndCallback, fetch, fsUtil, ignorefs, isTruthy, isUser, pathUtil, pick, queryEngine, rimraf, safefs, safeps, scandir, typeChecker, unbounded, union, uniq, util,
  hasProp = {}.hasOwnProperty,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

util = require('util');

pathUtil = require('path');

// External
({Logger, Human, Filter} = require('caterpillar'));

fsUtil = require('fs');

Errlop = require('errlop').default;

queryEngine = require('query-engine');

({uniq, union, pick} = require('underscore'));

CSON = require('cson');

balUtil = require('bal-util');

scandir = require('scandirectory');

extendr = require('extendr');

eachr = require('eachr');

typeChecker = require('typechecker');

ambi = require('ambi');

unbounded = require('unbounded');

({TaskGroup} = require('taskgroup'));

safefs = require('safefs');

safeps = require('safeps');

ignorefs = require('ignorefs');

rimraf = require('rimraf');

Progress = require('progress-title');

fetch = require('node-fetch');

extractOptsAndCallback = require('extract-opts');

({EventEmitterGrouped} = require('event-emitter-grouped'));

envFile = require('envfile');

ansiStyles = require('ansistyles');

// Base
({Events, Model, Collection, QueryCollection} = require('./base'));

// Utils
docpadUtil = require('./util');

// Models
FileModel = require('./models/file');

DocumentModel = require('./models/document');

// Collections
FilesCollection = require('./collections/files');

ElementsCollection = require('./collections/elements');

MetaCollection = require('./collections/meta');

ScriptsCollection = require('./collections/scripts');

StylesCollection = require('./collections/styles');

// Plugins
PluginLoader = require('@bevry/pluginloader').default;

BasePlugin = require('docpad-baseplugin');

// ---------------------------------
// Variables
isUser = docpadUtil.isUser();

isTruthy = function(i) {
  return Boolean(i);
};

DocPad = (function() {
  class DocPad extends EventEmitterGrouped {
    // Libraries
    // Here for legacy API reasons
    //@DocPad: DocPad
    //@Backbone: require('backbone')
    //@queryEngine: queryEngine

      // Allow for `DocPad.create()` as an alias for `new DocPad()`
    static create(...args) {
      return new this(...args);
    }

    // Require a local DocPad file
    // Before v6.73.0 this allowed requiring of files inside src/lib, as well as files inside src
    // After v6.73.0 it only allows requiring of files inside src/lib as that makes more sense
    // After v6.80.9 it only allows requiring specific aliases
    static require(name) {
      if (name === 'testers') {
        console.log(`'
docpad.require('testers') is deprecated, replacement instructions at: https://github.com/docpad/docpad-plugintester`);
        return require('docpad-plugintester');
      } else {
        throw new Errlop("docpad.require is limited to requiring: testers");
      }
    }

    /**
     * Get the DocPad version number
     * @method getVersion
     * @return {Number}
     */
    getVersion() {
      if (this.version == null) {
        this.version = require(this.packagePath).version;
      }
      return this.version;
    }

    /**
     * Get the DocPad version string
     * @method getVersionString
     * @return {String}
     */
    getVersionString() {
      if (docpadUtil.isLocalDocPadExecutable()) {
        return util.format(this.getLocale().versionLocal, this.getVersion(), this.corePath);
      } else {
        return util.format(this.getLocale().versionGlobal, this.getVersion(), this.corePath);
      }
    }

    // Process getters
    /**
     * Get the process platform
     * @method getProcessPlatform
     * @return {Object}
     */
    getProcessPlatform() {
      return process.platform;
    }

    /**
     * Get the process version string
     * @method getProcessVersion
     * @return {String}
     */
    getProcessVersion() {
      return process.version.replace(/^v/, '');
    }

    /**
     * Get the caterpillar logger instance bound to DocPad
     * @method getLogger
     * @return {Object} caterpillar logger
     */
    getLogger() {
      return this.logger;
    }

    /**
     * Destructor. Destroy the caterpillar logger instances bound to DocPad
     * @private
     * @method {Object} destroyLoggers
     */
    destroyLoggers() {
      // @logger.end()
      this.logger = null;
      return this;
    }

    /**
     * Create a timer and add it to the known timers
     * @method timer
     * @param {string} type - either timeout or interval
     * @param {number} time - the time to apply to the timer
     * @param {method} method - the method to use for the timer
     */
    timer(id, type, time, method) {
      var timer;
      if (this.timers == null) {
        this.timers = {};
      }
      // Create a new timer
      if (type != null) {
        this.timer(id); // clear
        if (type === 'timeout') {
          if (time === -1) {
            timer = setImmediate(method);
          } else {
            timer = setTimeout(method, time);
          }
        } else if (type === 'interval') {
          timer = setInterval(method, time);
        } else {
          throw new Errlop('unexpected type on new timer');
        }
        this.timers[id] = {id, type, time, method, timer};
      // Destroy an old timer
      } else if (this.timers[id]) {
        if (this.timers[id].type === 'interval') {
          clearInterval(this.timers[id].timer);
        } else if (this.timers[id].type === 'timeout') {
          if (this.timers[id].time === -1) {
            if (typeof clearImmediate === "function") {
              clearImmediate(this.timers[id].timer);
            }
          } else {
            clearTimeout(this.timers[id].timer);
          }
        } else {
          throw new Errlop('unexpected type on stored timer');
        }
        this.timers[id] = null;
      }
      return this;
    }

    /**
     * Destructor. Destroy all the timers we have kept.
     * @private
     * @method {Object} destroyTimers
     */
    destroyTimers(timer) {
      var key, ref, value;
      if (this.timers == null) {
        this.timers = {};
      }
      ref = this.timers;
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.timer(key);
      }
      return this;
    }

    /**
     * Update the configuration of the progress instance, to either enable it or disable it
     * Progress will be enabled if DocPad config 'progress' is true
     * @private
     * @method updateProgress
     * @param {boolean} [enabled] manually enable or disable the progress bar
     */
    updateProgress(enabled) {
      var config, debug, docpad, options;
      // Prepare
      docpad = this;
      config = docpad.getConfig();
      debug = this.getDebugging();
      // Enabled
      if (enabled == null) {
        enabled = config.progress;
      }
      // If we are in debug mode, then output more detailed title messages
      options = {};
      if (debug) {
        options.verbose = true;
        options.interval = 0;
      }
      // options.log = true

      // If we wish to have it enabled
      if (enabled) {
        if (this.progressInstance) {
          this.progressInstance.pause().configure(options).resume();
        } else {
          this.progressInstance = Progress.create(options).start();
        }
      } else if (this.progressInstance) {
        this.progressInstance.stop().configure(options);
      }
      // Return
      return this;
    }

    /**
     * Get the action runner instance bound to docpad
     * @method getActionRunner
     * @return {Object} the action runner instance
     */
    getActionRunner() {
      return this.actionRunnerInstance;
    }

    /**
     * Apply the passed DocPad action arguments
     * @method {Object} action
     * @param {Object} args
     * @return {Object}
     */
    action(action, opts, next) {
      var locale, ref;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      locale = this.getLocale();
      // Log
      if ((ref = this.progressInstance) != null) {
        ref.resume();
      }
      this.log('debug', util.format(locale.actionStart, action));
      // Act
      docpadUtil.action.call(this, action, opts, (...args) => {
        var err, ref1;
        // Prepare
        err = args[0];
        // Log
        if ((ref1 = this.progressInstance) != null) {
          ref1.stop();
        }
        if (err) {
          this.error(new Errlop(util.format(locale.actionFailure, action), err));
        } else {
          this.log('debug', util.format(locale.actionSuccess, action));
        }
        return typeof next === "function" ? next(...args) : void 0;
      });
      return this;
    }

    /**
     * Get the list of available events
     * @method getEvents
     * @return {Object} string array of event names
     */
    getEvents() {
      return this.events;
    }

    /**
     * Description for getDatabase
     * @method {Object} getDatabase
     */
    getDatabase() {
      return this.database;
    }

    /**
     * Destructor. Destroy the DocPad database
     * @private
     * @method destroyDatabase
     */
    destroyDatabase() {
      if (this.database != null) {
        this.database.destroy();
        this.database = null;
      }
      return this;
    }

    /* {
     * A collection of meta elements
    	meta: null  # Elements Collection

     * A collection of script elements
    	scripts: null  # Scripts Collection

     * Collection of style elements
    	styles: null  # Styles Collection
    }  */
    /**
     * Get a block by block name. Optionally clone block.
     * @method getBlock
     * @param {String} name
     * @param {Object} [clone]
     * @return {Object} block
     */
    getBlock(name, clone) {
      var block, classname;
      block = this.blocks[name];
      if (clone) {
        classname = name[0].toUpperCase() + name.slice(1) + 'Collection';
        block = new this[classname](block.models);
      }
      return block;
    }

    /**
     * Set a block by name and value
     * @method setBlock
     * @param {String} name
     * @param {Object} value
     */
    setBlock(name, value) {
      if (this.blocks[name] != null) {
        this.blocks[name].destroy();
        if (value) {
          this.blocks[name] = value;
        } else {
          delete this.blocks[name];
        }
      } else {
        this.blocks[name] = value;
      }
      return this;
    }

    /**
     * Get all blocks
     * @method getBlocks
     * @return {Object} collection of blocks
     */
    getBlocks() {
      return this.blocks;
    }

    /**
     * Set all blocks
     * @method setBlocks
     * @param {Object} blocks
     */
    setBlocks(blocks) {
      var name, value;
      for (name in blocks) {
        if (!hasProp.call(blocks, name)) continue;
        value = blocks[name];
        this.setBlock(name, value);
      }
      return this;
    }

    /**
     * Apply the passed function to each block
     * @method eachBlock
     * @param {Function} fn
     */
    eachBlock(fn) {
      eachr(this.blocks, fn);
      return this;
    }

    /**
     * Destructor. Destroy all blocks
     * @private
     * @method destroyBlocks
     */
    destroyBlocks() {
      var block, name, ref;
      if (this.blocks) {
        ref = this.blocks;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          block = ref[name];
          block.destroy();
          this.blocks[name] = null;
        }
      }
      return this;
    }

    /**
     * Get a collection by collection name or key.
     * This is often accessed within the docpad.coffee
     * file or a layout/page via @getCollection.
     * Because getCollection returns a docpad collection,
     * a call to this method is often chained with a
     * QueryEngine style query.
     *
     * 	@getCollection('documents').findAllLive({relativeOutDirPath: 'posts'},[{date:-1}])
     *
     * @method getCollection
     * @param {String} value
     * @return {Object} collection
     */
    getCollection(value) {
      var collection, j, k, len, len1, ref, ref1;
      if (value) {
        if (typeof value === 'string') {
          if (value === 'database') {
            return this.getDatabase();
          } else {
            ref = this.collections;
            for (j = 0, len = ref.length; j < len; j++) {
              collection = ref[j];
              if (value === collection.options.name || value === collection.options.key) {
                return collection;
              }
            }
          }
        } else {
          ref1 = this.collections;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            collection = ref1[k];
            if (value === collection) {
              return collection;
            }
          }
        }
      }
      return null;
    }

    /**
     * Destroy a collection by collection name or key
     * @method destroyCollection
     * @param {String} value
     * @return {Object} description
     */
    destroyCollection(value) {
      if (value) {
        if (typeof value === 'string' && value !== 'database') {
          this.collections = this.collections.filter(function(collection) {
            if (value === collection.options.name || value === collection.options.key) {
              if (collection != null) {
                collection.destroy();
              }
              return false;
            } else {
              return true;
            }
          });
        } else if (value !== this.getDatabase()) {
          this.collections = this.collections.filter(function(collection) {
            if (value === collection) {
              if (collection != null) {
                collection.destroy();
              }
              return false;
            } else {
              return true;
            }
          });
        }
      }
      return null;
    }

    /**
     * Add a collection
     * @method addCollection
     * @param {Object} collection
     */
    addCollection(collection) {
      if (collection && (collection !== this.getDatabase() && collection !== this.getCollection(collection))) {
        this.collections.push(collection);
      }
      return this;
    }

    /**
     * Set a name for a collection.
     * A collection can have multiple names
     *
     * The partials plugin (https://github.com/docpad/docpad-plugin-partials)
     * creates a live collection and passes this to setCollection with
     * the name 'partials'.
     *
     * 	# Add our partials collection
     *	docpad.setCollection('partials', database.createLiveChildCollection()
     *		.setQuery('isPartial', {
     *				$or:
     *					isPartial: true
     *					fullPath: $startsWith: config.partialsPath
     *		})
     *		.on('add', (model) ->
     *			docpad.log('debug', util.format(locale.addingPartial, model.getFilePath()))
     *			model.setDefaults(
     *				isPartial: true
     *				render: false
     *				write: false
     *			)
     *		)
     *	)
     *
     *
     * @method setCollection
     * @param {String} name the name to give to the collection
     * @param {Object} collection a DocPad collection
     */
    setCollection(name, collection) {
      if (collection) {
        if (name) {
          collection.options.name = name;
          if (this.getCollection(name) !== collection) {
            this.destroyCollection(name);
          }
        }
        return this.addCollection(collection);
      } else {
        return this.destroyCollection(name);
      }
    }

    /**
     * Get the DocPad project's collections
     * @method getCollections
     * @return {Object} the collections
     */
    getCollections() {
      return this.collections;
    }

    /**
     * Set the DocPad project's collections
     * @method setCollections
     */
    setCollections(collections) {
      var j, len, name, value;
      if (Array.isArray(collections)) {
        for (j = 0, len = collections.length; j < len; j++) {
          value = collections[j];
          this.addCollection(value);
        }
      } else {
        for (name in collections) {
          if (!hasProp.call(collections, name)) continue;
          value = collections[name];
          this.setCollection(name, value);
        }
      }
      return this;
    }

    /**
     * Apply the passed function to each collection
     * @method eachCollection
     * @param {Function} fn
     */
    eachCollection(fn) {
      var collection, index, j, len, ref;
      fn(this.getDatabase(), 'database');
      ref = this.collections;
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        collection = ref[index];
        fn(collection, collection.options.name || collection.options.key || index);
      }
      return this;
    }

    /**
     * Destructor. Destroy the DocPad project's collections.
     * @private
     * @method destroyCollections
     */
    destroyCollections() {
      var collection, j, len, ref;
      if (this.collections) {
        ref = this.collections;
        for (j = 0, len = ref.length; j < len; j++) {
          collection = ref[j];
          collection.destroy();
        }
        this.collections = [];
      }
      return this;
    }

    // ---------------------------------
    // Collection Helpers
    /**
     * Get all the files in the DocPad database (will use live collections)
     * @method getFiles
     * @param {Object} query
     * @param {Object} sorting
     * @param {Object} paging
     * @return {Object} collection
     */
    getFiles(query, sorting, paging) {
      var collection, key;
      key = JSON.stringify({query, sorting, paging});
      collection = this.getCollection(key);
      if (!collection) {
        collection = this.getDatabase().findAllLive(query, sorting, paging);
        collection.options.key = key;
        this.addCollection(collection);
      }
      return collection;
    }

    /**
     * Get a single file based on a query
     * @method getFile
     * @param {Object} query
     * @param {Object} sorting
     * @param {Object} paging
     * @return {Object} a file
     */
    getFile(query, sorting, paging) {
      var file;
      file = this.getDatabase().findOne(query, sorting, paging);
      return file;
    }

    /**
     * Get files at a path
     * @method getFilesAtPath
     * @param {String} path
     * @param {Object} sorting
     * @param {Object} paging
     * @return {Object} files
     */
    getFilesAtPath(path, sorting, paging) {
      var files, query;
      query = {
        $or: [
          {
            relativePath: {
              $startsWith: path
            }
          },
          {
            fullPath: {
              $startsWith: path
            }
          }
        ]
      };
      files = this.getFiles(query, sorting, paging);
      return files;
    }

    /**
     * Get a file at a relative or absolute path or url
     * @method getFileAtPath
     * @param {String} path
     * @param {Object} sorting
     * @param {Object} paging
     * @return {Object} a file
     */
    getFileAtPath(path, sorting, paging) {
      var file;
      file = this.getDatabase().fuzzyFindOne(path, sorting, paging);
      return file;
    }

    /**
     * Get a file by its id
     * @method getFileById
     * @param {String} id
     * @param {Object} [opts={}]
     * @return {Object} a file
     */
    getFileById(id, opts = {}) {
      var file;
      if (opts.collection == null) {
        opts.collection = this.getDatabase();
      }
      file = opts.collection.get(id);
      return file;
    }

    /**
     * Remove the query string from a url
     * Pathname convention taken from document.location.pathname
     * @method getUrlPathname
     * @param {String} url
     * @return {String}
     */
    getUrlPathname(url) {
      return url.replace(/\?.*/, '');
    }

    /**
     * Get a file by its selector (this is used to fetch layouts by their name)
     * @method getFileBySelector
     * @param {Object} selector
     * @param {Object} [opts={}]
     * @return {Object} a file
     */
    getFileBySelector(selector, opts = {}) {
      var file;
      if (opts.collection == null) {
        opts.collection = this.getDatabase();
      }
      file = opts.collection.fuzzyFindOne(selector);
      return file;
    }

    /**
     * Get Complete Template Data
     * @method getTemplateData
     * @param {Object} userTemplateData
     * @return {Object} templateData
     */
    getTemplateData(userTemplateData) {
      var base, base1, base2, docpad, locale, templateData;
      // Prepare
      userTemplateData || (userTemplateData = {});
      docpad = this;
      locale = this.getLocale();
      // Set the initial docpad template data
      if (this.initialTemplateData == null) {
        this.initialTemplateData = {
          // Site Properties
          site: {},
          // Environment
          getEnvironment: function() {
            return docpad.getEnvironment();
          },
          // Environments
          getEnvironments: function() {
            return docpad.getEnvironments();
          },
          // Set that we reference other files
          referencesOthers: function(flag) {
            var document;
            document = this.getDocument();
            document.referencesOthers();
            return null;
          },
          // Get the Document
          getDocument: function() {
            return this.documentModel;
          },
          // Get a Path in respect to the current document
          getPath: function(path, parentPath) {
            var document;
            document = this.getDocument();
            path = document.getPath(path, parentPath);
            return path;
          },
          // Get Files
          getFiles: function(query, sorting, paging) {
            var result;
            this.referencesOthers();
            result = docpad.getFiles(query, sorting, paging);
            return result;
          },
          // Get another file's URL based on a relative path
          getFile: function(query, sorting, paging) {
            var result;
            this.referencesOthers();
            result = docpad.getFile(query, sorting, paging);
            return result;
          },
          // Get Files At Path
          getFilesAtPath: function(path, sorting, paging) {
            var result;
            this.referencesOthers();
            path = this.getPath(path);
            result = docpad.getFilesAtPath(path, sorting, paging);
            return result;
          },
          // Get another file's model based on a relative path
          getFileAtPath: function(relativePath) {
            var path, result;
            this.referencesOthers();
            path = this.getPath(relativePath);
            result = docpad.getFileAtPath(path);
            return result;
          },
          // Get a specific file by its id
          getFileById: function(id) {
            var result;
            this.referencesOthers();
            result = docpad.getFileById(id);
            return result;
          },
          // Get the entire database
          getDatabase: function() {
            this.referencesOthers();
            return docpad.getDatabase();
          },
          // Get a pre-defined collection
          getCollection: function(name) {
            this.referencesOthers();
            return docpad.getCollection(name);
          },
          // Get a block
          getBlock: function(name) {
            return docpad.getBlock(name, true);
          },
          // Include another file taking in a relative path
          include: function(subRelativePath, strict = true) {
            var err, file;
            file = this.getFileAtPath(subRelativePath);
            if (file) {
              if (strict && file.get('rendered') === false) {
                if (docpad.getConfig().renderPasses === 1) {
                  docpad.warn(util.format(locale.renderedEarlyViaInclude, subRelativePath));
                }
                return null;
              }
              return file.getOutContent();
            } else {
              err = new Errlop(util.format(locale.includeFailed, subRelativePath));
              throw err;
            }
          }
        };
      }
      // Fetch our result template data
      templateData = extendr.extend({}, this.initialTemplateData, this.pluginsTemplateData, this.getConfig().templateData, userTemplateData);
      // Add site data
      (base = templateData.site).url || (base.url = '');
      (base1 = templateData.site).date || (base1.date = new Date());
      (base2 = templateData.site).keywords || (base2.keywords = []);
      if (typeChecker.isString(templateData.site.keywords)) {
        templateData.site.keywords = templateData.site.keywords.split(/,\s*/g);
      }
      // Return
      return templateData;
    }

    /**
     * Get the locale (language code and locale code)
     * @method getLocale
     * @return {Object} locale
     */
    getLocale(key) {
      var err, localeError, locales;
      if (this.locale == null) {
        try {
          locales = this.getPath('locales').map(function(locale) {
            return require(locale);
          });
          this.locale = extendr.extend(...locales);
        } catch (error1) {
          localeError = error1;
          docpad.warn(new Errlop('Failed to load a locale', localeError));
          try {
            this.locale = require(this.getPath('locale'));
          } catch (error1) {
            err = error1;
            docpad.fatal(new Errlop('Failed to load any locale', err));
            this.locale = {};
          }
        }
      }
      if (key) {
        return this.locale[key] || key;
      } else {
        return this.locale;
      }
    }

    // -----------------------------
    // Environments
    /**
     * Get the DocPad environment, eg: development,
     * production or static
     * @method getEnvironment
     * @return {String} the environment
     */
    getEnvironment() {
      return this.env;
    }

    /**
     * Get the environments
     * @method getEnvironments
     * @return {Array} array of environment strings
     */
    getEnvironments() {
      return this.envs;
    }

    /**
     * Get the DocPad configuration
     * @method getConfig
     * @return {Object} the DocPad configuration object
     */
    getConfig() {
      return this.config || {};
    }

    // =================================
    // Initialization Functions
    /**
     * Create our own custom TaskGroup instance for DocPad.
     * That will listen to tasks as they execute and provide debugging information.
     * @method createTaskGroup
     * @param {Object} opts
     * @return {TaskGroup}
     */
    createTaskGroup(...opts) {
      var docpad, progress, tasks;
      boundMethodCheck(this, DocPad);
      docpad = this;
      progress = docpad.progressInstance;
      tasks = TaskGroup.create(...opts);
      // Listen to executing tasks and output their progress
      tasks.on('running', function() {
        var config, name, totals;
        config = tasks.getConfig();
        name = tasks.getNames();
        if (progress) {
          totals = tasks.getItemTotals();
          return progress.update(name, totals);
        } else {
          return docpad.log('debug', name + ' > running');
        }
      });
      // Listen to executing tasks and output their progress
      tasks.on('item.add', function(item) {
        var config, name;
        config = tasks.getConfig();
        name = item.getNames();
        if (!progress) {
          docpad.log('debug', name + ' > added');
        }
        // Listen to executing tasks and output their progress
        item.on('started', function(item) {
          var totals;
          config = tasks.getConfig();
          name = item.getNames();
          if (progress) {
            totals = tasks.getItemTotals();
            return progress.update(name, totals);
          } else {
            return docpad.log('debug', name + ' > started');
          }
        });
        // Listen to executing tasks and output their progress
        return item.done(function(err) {
          var totals;
          config = tasks.getConfig();
          name = item.getNames();
          if (progress) {
            totals = tasks.getItemTotals();
            return progress.update(name, totals);
          } else {
            return docpad.log('debug', name + ' > done');
          }
        });
      });
      // Return
      return tasks;
    }

    /**
     * Constructor method. Sets up the DocPad instance.
     * next(err)
     * @method constructor
     * @param {Object} instanceConfig
     * @param {Function} next callback
     * @param {Error} next.err
     * @param {DocPad} next.docpad
     */
    constructor(instanceConfig, next) {
      var color, configEventContext, docpad, filter, j, len, lineLevel, logPath, logger, methodName, ref;
      super();
      this.createTaskGroup = this.createTaskGroup.bind(this);
      [instanceConfig, next] = extractOptsAndCallback(instanceConfig, next);
      docpad = this;
      // Allow DocPad to have unlimited event listeners
      this.setMaxListeners(0);
      ref = "action log warn error fatal inspect notify checkRequest activeHandles onBeforeExit onSignalInterruptOne onSignalInterruptTwo onSignalInterruptThree destroyWatchers".split(/\s+/);
      // Binders
      // Using this over coffescript's => on class methods, ensures that the method length is kept
      for (j = 0, len = ref.length; j < len; j++) {
        methodName = ref[j];
        this[methodName] = this[methodName].bind(this);
      }
      // Adjust configPaths
      if (typeChecker.isString(instanceConfig.configPaths)) {
        instanceConfig.configPaths = [instanceConfig.configPaths];
      }
      // Dereference and initialise advanced variables
      // we deliberately ommit initialTemplateData here, as it is setup in getTemplateData
      this.slowPlugins = {};
      this.loadedPlugins = {};
      this.pluginsTemplateData = {};
      this.collections = [];
      this.blocks = {};
      this.websitePackageConfig = {};
      this.websiteConfig = {};
      this.userConfig = {};
      this.initialConfig = extendr.dereferenceJSON(this.initialConfig);
      this.instanceConfig = instanceConfig || {};
      this.config = this.mergeConfigs();
      // Prepare the loggers
      if (instanceConfig.logLevel == null) {
        instanceConfig.logLevel = this.initialConfig.logLevel;
      }
      color = instanceConfig.color;
      lineLevel = -1;
      if (instanceConfig.silent) {
        instanceConfig.logLevel = 3; // 3:error, 2:critical, 1:alert, 0:emergency
        instanceConfig.progress = instanceConfig.welcome = false;
      }
      if (instanceConfig.verbose || instanceConfig.debug) {
        instanceConfig.logLevel = 7;
        lineLevel = 7;
      }
      // Create the loggers
      logger = new Logger({
        lineLevel: lineLevel
      });
      filter = new Filter({
        filterLevel: instanceConfig.logLevel
      });
      // Apply the loggers
      this.logger = logger;
      // Console
      logger.pipe(filter).pipe(new Human({
        color: color
      })).pipe(process.stdout);
      // File
      if (instanceConfig.debug) {
        logPath = this.getPath(false, 'log');
        safefs.unlink(logPath, function() {
          return logger.pipe(new Human({
            color: false
          })).pipe(fsUtil.createWriteStream(logPath));
        });
      }
      // Forward log events to the logger
      this.on('log', function(...args) {
        return docpad.log.apply(this, args);
      });
      // Setup configuration event wrappers
      configEventContext = {docpad}; // here to allow the config event context to persist between event calls
      this.getEvents().forEach(function(eventName) {
        // Bind to the event
        return docpad.on(eventName, function(opts, next) {
          var args, eventHandler, ref1;
          eventHandler = (ref1 = docpad.getConfig().events) != null ? ref1[eventName] : void 0;
          // Fire the config event handler for this event, if it exists
          if (typeChecker.isFunction(eventHandler)) {
            args = [opts, next];
            return ambi(unbounded.binder.call(eventHandler, configEventContext), ...args);
          } else {
            // It doesn't exist, so lets continue
            return next();
          }
        });
      });
      // Create our action runner
      this.actionRunnerInstance = this.createTaskGroup('action runner', {
        abortOnError: false,
        destroyOnceDone: false
      }).whenDone(function(err) {
        var ref1;
        if ((ref1 = docpad.progressInstance) != null) {
          ref1.update('');
        }
        if (err) {
          return docpad.error(err);
        }
      });
      // Setup the database
      this.database = new FilesCollection(null, {
        name: 'database'
      }).on('remove', function(model, options) {
        var outPath, updatedModels;
        // Skip if we are not a writeable file
        if (model.get('write') === false) {
          return;
        }
        // Ensure we regenerate anything (on the next regeneration) that was using the same outPath
        outPath = model.get('outPath');
        if (outPath) {
          updatedModels = docpad.database.findAll({outPath});
          updatedModels.remove(model);
          if (updatedModels.length) {
            updatedModels.each(function(model) {
              return model.set({
                'mtime': new Date()
              });
            });
            docpad.log('info', 'Updated mtime for these models due to the removal of a similar one:', updatedModels.pluck('relativePath'));
          }
        }
        // Return safely
        return true;
      }).on('add change:outPath', function(model) {
        var existingModels, outPath, previousModels, previousOutPath;
        // Skip if we are not a writeable file
        if (model.get('write') === false) {
          return;
        }
        // Prepare
        outPath = model.get('outPath');
        previousOutPath = model.previous('outPath');
        // Check if we have changed our outPath
        if (previousOutPath) {
          // Ensure we regenerate anything (on the next regeneration) that was using the same outPath
          previousModels = docpad.database.findAll({
            outPath: previousOutPath
          });
          previousModels.remove(model);
          if (previousModels.length) {
            previousModels.each(function(previousModel) {
              return previousModel.set({
                'mtime': new Date()
              });
            });
            docpad.log('info', 'Updated mtime for these models due to the addition of a similar one:', previousModels.pluck('relativePath'));
          }
        }
        // Determine if there are any conflicts with the new outPath
        if (outPath) {
          existingModels = docpad.database.findAll({outPath});
          existingModels.each(function(existingModel) {
            var existingModelPath, modelPath;
            if (existingModel.id !== model.id) {
              modelPath = model.get('fullPath') || (model.get('relativePath') + ':' + model.id);
              existingModelPath = existingModel.get('fullPath') || (existingModel.get('relativePath') + ':' + existingModel.id);
              return docpad.warn(util.format(docpad.getLocale().outPathConflict, outPath, modelPath, existingModelPath));
            }
          });
        }
        // Return safely
        return true;
      });
      // Continue with load and ready
      this.action('load ready', {}, function(err) {
        if (next != null) {
          return next(err, docpad);
        } else if (err) {
          return docpad.fatal(err);
        }
      });
      // Chain
      this;
    }

    /**
     * Destructor. Destroy the DocPad instance
     * This is an action, and should be called as such
     * E.g. docpad.action('destroy', next)
     * @method destroy
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    destroy(opts, next) {
      var config, docpad, dropped, locale;
      if (this.destroying) {
        return this;
      }
      this.destroying = true;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      locale = this.getLocale();
      // Log
      docpad.log('info', locale.destroyDocPad);
      // Drop all the remaining tasks
      dropped = this.getActionRunner().clearRemaining();
      if (dropped) {
        docpad.error(`DocPad destruction had to drop ${Number(dropped)} action tasks`);
      }
      // Destroy Timers
      docpad.destroyTimers();
      // Wait a configurable oment
      docpad.timer('destroy', 'timeout', config.destroyDelay, function() {
        // Destroy Plugins
        return docpad.emitSerial('docpadDestroy', function(eventError) {
          var err, finalError;
          // Check
          if (eventError) {
            // Note
            err = new Errlop("DocPad's destroyEvent event failed", eventError);
            docpad.fatal(err);
            return typeof next === "function" ? next(err) : void 0;
          }
          try {
            // Destroy Timers
            // Final closures and checks
            docpad.destroyTimers();
            // Destroy Plugins
            docpad.destroyPlugins();
            // Destroy Watchers
            docpad.destroyWatchers();
            // Destroy Blocks
            docpad.destroyBlocks();
            // Destroy Collections
            docpad.destroyCollections();
            // Destroy Database
            docpad.destroyDatabase();
            // Destroy progress
            docpad.updateProgress(false);
            // Destroy Logging
            docpad.destroyLoggers();
            // Destroy Process Listeners
            process.removeListener('uncaughtException', docpad.fatal);
            process.removeListener('uncaughtException', docpad.error);
            process.removeListener('beforeExit', docpad.onBeforeExit);
            process.removeListener('SIGINT', docpad.onSignalInterruptOne);
            process.removeListener('SIGINT', docpad.onSignalInterruptTwo);
            process.removeListener('SIGINT', docpad.onSignalInterruptThree);
            // Destroy DocPad Listeners
            docpad.removeAllListeners();
          } catch (error1) {
            finalError = error1;
            // Note
            err = new Errlop("DocPad's final destruction efforts failed", finalError);
            docpad.fatal(err);
            return typeof next === "function" ? next(err) : void 0;
          }
          // Success
          docpad.log(locale.destroyedDocPad); // log level omitted, as this will hit console.log
          return typeof next === "function" ? next() : void 0;
        });
      });
      return this;
    }

    /**
     * Emit event, serial
     * @private
     * @method emitSerial
     * @param {String} eventName
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    emitSerial(eventName, opts, next) {
      var docpad, locale;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      locale = docpad.getLocale();
      // Log
      docpad.log('debug', util.format(locale.emittingEvent, eventName));
      // Emit
      super.emitSerial(eventName, opts, function(err) {
        if (err) {
          // Check
          return next(err);
        }
        // Log
        docpad.log('debug', util.format(locale.emittedEvent, eventName));
        // Forward
        return next(err);
      });
      return this;
    }

    /**
     * Emit event, parallel
     * @private
     * @method emitParallel
     * @param {String} eventName
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    emitParallel(eventName, opts, next) {
      var docpad, locale;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      locale = docpad.getLocale();
      // Log
      docpad.log('debug', util.format(locale.emittingEvent, eventName));
      // Emit
      super.emitParallel(eventName, opts, function(err) {
        if (err) {
          // Check
          return next(err);
        }
        // Log
        docpad.log('debug', util.format(locale.emittedEvent, eventName));
        // Forward
        return next(err);
      });
      return this;
    }

    // =================================
    // Helpers
    /**
     * Get the ignore options for the DocPad project
     * @method getIgnoreOpts
     * @return {Array} string array of ignore options
     */
    getIgnoreOpts() {
      return pick(this.config, ['ignorePaths', 'ignoreHiddenFiles', 'ignoreCommonPatterns', 'ignoreCustomPatterns']);
    }

    /**
     * Is the supplied path ignored?
     * @method isIgnoredPath
     * @param {String} path
     * @param {Object} [opts={}]
     * @return {Boolean}
     */
    isIgnoredPath(path, opts = {}) {
      opts = extendr.extend(this.getIgnoreOpts(), opts);
      return ignorefs.isIgnoredPath(path, opts);
    }

    /**
     * Scan directory
     * @method scandir
     * @param {Object} [opts={}]
     */
    //NB: How does this work? What is returned?
    //Does it require a callback (next) passed as
    //one of the options
    scandir(opts = {}) {
      opts = extendr.extend(this.getIgnoreOpts(), opts);
      return scandir(opts);
    }

    /**
     * Watch Directory. Wrapper around the Bevry watchr
     * module (https://github.com/bevry/watchr). Used
     * internally by DocPad to watch project documents
     * and files and then activate the regeneration process
     * when any of those items are updated.
     * @private
     * @method watchdir
     * @param {String} path - the path to watch
     * @param {Object} listeners - listeners to attach to the watcher
     * @param {Function} next - completion callback accepting error
     * @return {Object} the watcher
     */
    watchdir(path, listeners, next) {
      var key, opts, stalker, value;
      opts = extendr.extend(this.getIgnoreOpts(), this.config.watchOptions || {});
      stalker = require('watchr').create(path);
      for (key in listeners) {
        if (!hasProp.call(listeners, key)) continue;
        value = listeners[key];
        stalker.on(key, value);
      }
      stalker.setConfig(opts);
      stalker.watch(next);
      return stalker;
    }

    /**
     * Watch Directories. Wrapper around watchdir.
     * @private
     * @method watchdirs
     * @param {Array} paths - the paths to watch
     * @param {Object} listeners - listeners to attach to the watcher
     * @param {Function} next - completion callback accepting error and watchers/stalkers
     */
    watchdirs(paths, listeners, next) {
      var docpad, stalkers, tasks;
      docpad = this;
      stalkers = [];
      tasks = new TaskGroup('watching directories').setConfig({
        concurrency: 0
      }).done(function(err) {
        var j, len, stalker;
        if (err) {
          for (j = 0, len = stalkers.length; j < len; j++) {
            stalker = stalkers[j];
            stalker.close();
          }
          return next(err);
        } else {
          return next(err, stalkers);
        }
      });
      paths.forEach(function(path) {
        return tasks.addTask(`watching ${path}`, function(done) {
          // check if the dir exists first as reloadPaths may not apparently
          return safefs.exists(path, function(exists) {
            if (!exists) {
              return done();
            }
            return stalkers.push(docpad.watchdir(path, listeners, done));
          });
        });
      });
      tasks.run();
      return this;
    }

    // =================================
    // Setup and Loading
    /**
     * DocPad is ready. Peforms the tasks needed after DocPad construction
     * and DocPad has loaded. Triggers the docpadReady event.
     * next(err,docpadInstance)
     * @private
     * @method ready
     * @param {Object} [opts]
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.docpadInstance
     */
    ready(opts, next) {
      var config, docpad, instanceConfig, locale, pluginsList, tasks;
      // Prepare
      [instanceConfig, next] = extractOptsAndCallback(instanceConfig, next);
      docpad = this;
      config = this.getConfig();
      locale = this.getLocale();
      // Render Single Extensions
      this.DocumentModel.prototype.defaults.renderSingleExtensions = config.renderSingleExtensions;
      // Fetch the plugins
      pluginsList = Object.keys(this.loadedPlugins).sort().join(', ');
      // Welcome Output
      docpad.log('info', util.format(locale.welcome, this.getVersionString()));
      docpad.log('notice', locale.welcomeDonate);
      docpad.log('info', locale.welcomeContribute);
      docpad.log('info', util.format(locale.welcomePlugins, pluginsList));
      docpad.log('info', util.format(locale.welcomeEnvironment, this.getEnvironment()));
      // Prepare
      tasks = this.createTaskGroup('ready tasks').done(function(err) {
        if (err) {
          // Error?
          return docpad.error(err);
        }
        return typeof next === "function" ? next(null, docpad) : void 0;
      });
      // kept here in case plugins use it
      tasks.addTask('welcome event', function(complete) {
        if (!config.welcome) {
          // No welcome
          return complete();
        }
        // Welcome
        return docpad.emitSerial('welcome', {docpad}, complete);
      });
      tasks.addTask('emit docpadReady', function(complete) {
        return docpad.emitSerial('docpadReady', {docpad}, complete);
      });
      // Run tasks
      tasks.run();
      return this;
    }

    /**
     * Performs the merging of the passed configuration objects
     * @private
     * @method mergeConfigs
     */
    mergeConfigs(configPackages, destination = {}) {
      var configPackage, configsToMerge, env, envConfig, j, k, len, len1, ref, ref1;
      // A plugin is calling us with its configuration
      if (!configPackages) {
        // Apply the environment
        // websitePackageConfig.env is left out of the detection here as it is usually an object
        // that is already merged with our process.env by the environment runner
        // rather than a string which is the docpad convention
        this.env = this.instanceConfig.env || this.websiteConfig.env || this.initialConfig.env || process.env.NODE_ENV || 'development';
        this.envs = this.env.split(/[, ]+/);
        // Merge the configurations together
        configPackages = [this.initialConfig, this.userConfig, this.websiteConfig, this.instanceConfig];
      }
      // Figure out merging
      configsToMerge = [destination];
      for (j = 0, len = configPackages.length; j < len; j++) {
        configPackage = configPackages[j];
        if (!configPackage) {
          continue;
        }
        configsToMerge.push(configPackage);
        ref = this.envs;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          env = ref[k];
          envConfig = (ref1 = configPackage.environments) != null ? ref1[env] : void 0;
          if (envConfig) {
            configsToMerge.push(envConfig);
          }
        }
      }
      // Merge
      return extendr.deep(...configsToMerge);
    }

    /**
     * Legacy version of mergeConmergeConfigsfigurations
     * @private
     * @method mergeConfigurations
     */
    mergeConfigurations(configPackages, [destination]) {
      return this.mergeConfigs(configPackages, destination);
    }

    /**
     * Set the DocPad configuration object.
     * Performs a number of tasks, including
     * merging the pass instanceConfig with DocPad's
     * other config objects.
     * next(err,config)
     * @private
     * @method setConfig
     * @param {Object} instanceConfig
     * @param {Object} next
     * @param {Error} next.err
     * @param {Object} next.config
     */
    setConfig(instanceConfig) {
      var docpad, locale, next;
      // Prepare
      [instanceConfig, next] = extractOptsAndCallback(instanceConfig, next);
      docpad = this;
      locale = this.getLocale();
      if (instanceConfig) {
        // Apply the instance configuration, generally we won't have it at this level
        // as it would have been applied earlier the load step
        extendr.deepDefaults(this.instanceConfig, instanceConfig);
      }
      // Merge the configurations together
      this.config = this.mergeConfigs();
      // Update the progress bar configuration
      this.updateProgress();
      // Handle errors
      process.removeListener('uncaughtException', this.fatal);
      process.removeListener('uncaughtException', this.error);
      this.removeListener('error', this.fatal);
      this.removeListener('error', this.error);
      if (this.config.catchExceptions) { // legacy
        this.config.catchOurExceptions = this.config.catchUncaughtExceptions = 'error';
      }
      if (this.config.catchUncaughtExceptions) {
        process.setMaxListeners(0);
        if (this.config.catchUncaughtExceptions === 'error') {
          process.on('uncaughtException', this.error);
        } else {
          process.on('uncaughtException', this.fatal);
        }
      }
      if (this.config.catchOurExceptions) {
        if (this.config.catchUncaughtExceptions === 'fatal') {
          this.on('error', this.fatal);
        } else {
          this.on('error', this.error);
        }
      }
      // Handle interrupt
      process.removeListener('beforeExit', this.onBeforeExit);
      process.removeListener('SIGINT', this.onSignalInterruptOne);
      process.removeListener('SIGINT', this.onSignalInterruptTwo);
      process.removeListener('SIGINT', this.onSignalInterruptThree);
      if (this.config.destroyOnExit) {
        process.once('beforeExit', this.onBeforeExit);
      }
      if (this.config.destroyOnSignalInterrupt) {
        process.once('SIGINT', this.onSignalInterruptOne);
      }
      return this;
    }

    onSignalInterruptOne() {
      // Log
      this.log('notice', "Signal Interrupt received, queued DocPad's destruction");
      // Escalate next time
      process.once('SIGINT', this.onSignalInterruptTwo);
      // Act
      this.action('destroy');
      return this;
    }

    onSignalInterruptTwo() {
      var ref, ref1, ref2;
      // Log
      this.log('alert', 'Signal Interrupt received again, closing stdin and dumping handles');
      // Escalate next time
      process.once('SIGINT', this.onSignalInterruptThree);
      // Handle any errors that occur when stdin is closed
      // https://github.com/docpad/docpad/pull/1049
      if ((ref = process.stdin) != null) {
        if (typeof ref.once === "function") {
          ref.once('error', function(stdinError) {
            var err;
            // ignore ENOTCONN as it means stdin was already closed when we called stdin.end
            // node v8 and above have stdin.destroy to avoid emitting this error
            if (stdinError.toString().indexOf('ENOTCONN') === -1) {
              err = new Errlop("closing stdin encountered an error", stdinError);
              return docpad.fatal(err);
            }
          });
        }
      }
      // Close stdin
      // https://github.com/docpad/docpad/issues/1028
      // https://github.com/docpad/docpad/pull/1029
      ((ref1 = process.stdin) != null ? typeof ref1.destroy === "function" ? ref1.destroy() : void 0 : void 0) || ((ref2 = process.stdin) != null ? typeof ref2.end === "function" ? ref2.end() : void 0 : void 0);
      // Wait a moment before outputting things that are preventing closure
      setImmediate(this.activeHandles);
      return this;
    }

    onSignalInterruptThree() {
      // Log
      this.log('alert', 'Signal Interrupt received yet again, skipping queue and destroying DocPad right now');
      // Act
      this.exitCode(130);
      this.destroy();
      return this;
    }

    onBeforeExit() {
      return this.action('destroy');
    }

    activeHandles() {
      var activeHandles, activeRequests;
      // Note any requests that are still active
      activeRequests = typeof process._getActiveRequests === "function" ? process._getActiveRequests() : void 0;
      if (activeRequests != null ? activeRequests.length : void 0) {
        docpadUtil.writeStderr(`Waiting on these ${activeRequests.length} requests to close:
${this.inspect(activeRequests)}`);
      }
      // Note any handles that are still active
      activeHandles = typeof process._getActiveHandles === "function" ? process._getActiveHandles() : void 0;
      if (activeHandles != null ? activeHandles.length : void 0) {
        return docpadUtil.writeStderr(`Waiting on these ${activeHandles.length} handles to close:
${this.inspect(activeHandles)}`);
      }
    }

    /**
     * Load the various configuration files from the
     * file system. Set the instanceConfig.
     * next(err,config)
     * @private
     * @method load
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    load(opts, next) {
      var config, docpad, loadTasks, locale;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      locale = this.getLocale();
      config = this.getConfig();
      // Prepare the Load Tasks
      loadTasks = this.createTaskGroup('load tasks').done(next);
      // User Configuration
      loadTasks.addTask("load the user's configuration", (complete) => {
        var userConfigPath;
        userConfigPath = this.getPath('user');
        if (!userConfigPath) {
          return complete();
        }
        docpad.log('debug', util.format(locale.loadingUserConfig, userConfigPath));
        return this.loadConfigPath(userConfigPath, (err, data) => {
          if (err) {
            return complete(err);
          }
          // Apply
          if (data) {
            this.userConfig = data;
            docpad.log('debug', util.format(locale.loadedUserConfig, userConfigPath));
            return complete();
          }
          // Complete
          return complete();
        });
      });
      // Website Env Configuration
      loadTasks.addTask("read the .env file if it exists", (complete) => {
        var envPath;
        envPath = this.getPath('env');
        if (!envPath) {
          return complete();
        }
        docpad.log('debug', util.format(locale.loadingEnvConfig, envPath));
        return envFile.parseFile(envPath, function(err, data) {
          var key, value;
          if (err) {
            return complete(err);
          }
          for (key in data) {
            if (!hasProp.call(data, key)) continue;
            value = data[key];
            process.env[key] = value;
          }
          docpad.log('debug', util.format(locale.loadedEnvConfig, envPath));
          return complete();
        });
      });
      // Website Package Configuration
      loadTasks.addTask("load the website's package data", (complete) => {
        var packagePath;
        packagePath = this.getPath('package');
        if (!packagePath) {
          return complete();
        }
        docpad.log('debug', util.format(locale.loadingWebsitePackageConfig, packagePath));
        return this.loadConfigPath(packagePath, (err, data) => {
          if (err) {
            return complete(err);
          }
          // Apply
          if (data) {
            this.websitePackageConfig = data;
            docpad.log('debug', util.format(locale.loadedWebsitePackageConfig, packagePath));
          }
          // Complete
          return complete();
        });
      });
      // Website Configuration
      loadTasks.addTask("load the website's configuration", (complete) => {
        var configPath;
        configPath = this.getPath('config');
        if (!configPath) {
          return complete();
        }
        docpad.log('debug', util.format(locale.loadingWebsiteConfig, configPath));
        return this.loadConfigPath(configPath, (err, data) => {
          if (err) {
            return complete(err);
          }
          // Apply
          if (data) {
            this.websiteConfig = data;
            docpad.log('debug', util.format(locale.loadedWebsiteConfig, configPath));
          }
          // Complete
          return complete();
        });
      });
      loadTasks.addTask("update the configurations", () => {
        return this.setConfig();
      });
      /*
      loadTasks.addTask 'lazy dependencies: encoding', (complete) =>
      	lazyRequire = require('lazy-require')
      	return complete()  unless @config.detectEncoding
      	return lazyRequire 'encoding', {cwd:corePath, stdio:'inherit'}, (err) ->
      		docpad.warn(locale.encodingLoadFailed)  if err
      		return complete()
      */
      loadTasks.addTask('load plugins', function(complete) {
        return docpad.loadPlugins(complete);
      });
      loadTasks.addTask('extend collections', function(complete) {
        return docpad.extendCollections(complete);
      });
      loadTasks.addTask('fetch plugins templateData', function(complete) {
        return docpad.emitSerial('extendTemplateData', {
          templateData: docpad.pluginsTemplateData
        }, complete);
      });
      // Fire post tasks
      loadTasks.run();
      return this;
    }

    // =================================
    // Configuration
    /**
     * Update user configuration with the passed data
     * @method updateUserConfig
     * @param {Object} [data={}]
     * @param {Function} next
     * @param {Error} next.err
     */
    updateUserConfig(data = {}, next) {
      var docpad, userConfigPath;
      // Prepare
      [data, next] = extractOptsAndCallback(data, next);
      docpad = this;
      userConfigPath = this.getConfig(false, 'user');
      if (data) {
        // Apply back to our loaded configuration
        // does not apply to @config as we would have to reparse everything
        // and that appears to be an imaginary problem
        extendr.extend(this.userConfig, data);
      }
      // Convert to CSON
      CSON.createCSONString(this.userConfig, function(parseError, userConfigString) {
        var err;
        if (parseError) {
          err = new Errlop("Failed to create the CSON string for the user configuration", parseError);
          return next(err);
        }
        // Write it
        return safefs.writeFile(userConfigPath, userConfigString, 'utf8', function(writeError) {
          if (writeError) {
            err = new Errlop(`Failed to write the CSON string for the user configuration to ${userConfigPath}`, writeError);
            return next(err);
          }
          // Forward
          return next();
        });
      });
      return this;
    }

    /**
     * Load a configuration url.
     * @method loadConfigUrl
     * @param {String} configUrl
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.parsedData
     */
    loadConfigUrl(configUrl, next) {
      var config, docpad, locale;
      // Prepare
      docpad = this;
      locale = this.getLocale();
      config = this.getConfig();
      // Log
      docpad.log('debug', util.format(locale.loadingConfigUrl, configUrl));
      // Read the URL
      fetch(configUrl, {
        timeout: config.requestTimeout
      }).then(function(res) {
        return res.text();
      }).then(function(text) {
        return CSON.parseCSONString(text);
      }).catch(next).then(function(data) {
        return next(null, data);
      });
      return this;
    }

    /**
     * Load the configuration from a file path
     * passed as one of the options (opts.configPath) or
     * from DocPad's configPaths
     * @private
     * @method loadConfigPath
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.parsedData
     */
    loadConfigPath(configPath, next) {
      var csonOptions, docpad, locale;
      // Prepare
      docpad = this;
      locale = this.getLocale();
      if (!configPath) {
        // Check
        return next();
      }
      // Log
      docpad.log('debug', util.format(locale.loadingConfigPath, configPath));
      // Prepare CSON Options
      csonOptions = {
        cson: true,
        json: true,
        coffeescript: true,
        javascript: true
      };
      // Read the path using CSON
      CSON.requireFile(configPath, csonOptions, function(parseError, data) {
        var err, executeError;
        if (parseError) {
          err = new Errlop(util.format(locale.loadingConfigPathFailed, configPath), parseError);
          return next(err);
        }
        // Check if the data is a function, if so, then execute it as one
        while (typeChecker.isFunction(data)) {
          try {
            data = data(docpad);
          } catch (error1) {
            executeError = error1;
            err = new Errlop(util.format(locale.executeConfigPathFailed, configPath), executeError);
            return next(err);
          }
        }
        if (!typeChecker.isObject(data)) {
          err = new Errlop(util.format(locale.invalidConfigPathData, configPath, docpad.inspect(data)));
          return next(err);
        }
        // Return the data
        return next(null, data);
      });
      return this;
    }

    resolvePath(...args) {
      var error, path;
      try {
        path = pathUtil.resolve(...args);
        if (safefs.existsSync(path)) {
          return path;
        }
      } catch (error1) {
        error = error1;
        this.log('error', 'failed to resolve the path:', {path, error});
        throw error;
      }
      return false;
    }

    getPath(...args) {
      var check, config, error, method, name, path, tail;
      // Use join if first argument is false
      if (typeChecker.isBoolean(args[0])) {
        [check, name, ...tail] = args;
      } else {
        check = true;
        [name, ...tail] = args;
      }
      // Prepare
      method = check ? this.resolvePath : pathUtil.resolve;
      config = this.getConfig();
      // Determine
      path = (function() {
        switch (name) {
          case 'locales':
            return [pathUtil.resolve(this.localePath, 'en.js')];
          case /*
uniq([
	safeps.getLocaleCode   config.localeCode
	safeps.getLocaleCode   safeps.getLocaleCode()
	safeps.getLanguageCode config.localeCode
	safeps.getLanguageCode safeps.getLocaleCode()
	'en'
]).map((code) => @resolvePath(@localePath, code + '.js'))
*/'locale':
            return this.getPath(check, 'locales')[0];
          case 'root':
            return method(check, config.rootPath);
          case 'log':
            return method(check, process.cwd(), config.debugLogPath);
          case 'out':
            return this.getPath(check, 'root', config.outPath);
          case 'env':
            return this.getPath(check, 'root', '.env');
          case 'home':
            return require('os').homedir(); // works in node v4 and above
          case 'dropbox':
            return this.getPath(check, 'home', 'Dropbox');
          case 'users':
            return [this.getPath(check, 'dropbox', config.userConfigPath), this.getPath(check, 'root', config.userConfigPath)].filter(isTruthy);
          case 'user':
            return this.getPath(check, 'users')[0] || false;
          case 'package':
            return this.getPath(check, 'root', config.packagePath);
          case 'sources':
            return config.sourcePaths.map((path) => {
              return this.getPath(check, 'root', path);
            }).filter(isTruthy);
          case 'source':
            return this.getPath(check, 'sources')[0] || false;
          case 'configs':
            return config.configPaths.map((path) => {
              return this.getPath(check, 'root', path);
            }).filter(isTruthy);
          case 'config':
            return this.getPath(check, 'configs')[0] || false;
          case 'documents':
            return config.documentsPaths.map((path) => {
              return this.getPath(check, 'source', path);
            }).filter(isTruthy);
          case 'document':
            return this.getPath(check, 'documents')[0] || false;
          case 'files':
            return config.filesPaths.map((path) => {
              return this.getPath(check, 'source', path);
            }).filter(isTruthy);
          case 'file':
            return this.getPath(check, 'files')[0] || false;
          case 'layouts':
            return config.layoutsPaths.map((path) => {
              return this.getPath(check, 'source', path);
            }).filter(isTruthy);
          case 'layout':
            return this.getPath(check, 'layouts')[0] || false;
          case 'reloads':
            return config.reloadPaths.map((path) => {
              return this.getPath(check, 'source', path);
            }).filter(isTruthy);
          case 'regenerates':
            return config.regeneratePaths.map((path) => {
              return this.getPath(check, 'source', path);
            }).filter(isTruthy);
          default:
            return null;
        }
      }).call(this);
      try {
        if (typeof path === 'string' && tail.length) {
          return method(check, path, ...tail);
        } else {
          return path;
        }
      } catch (error1) {
        error = error1;
        this.log('error', 'failed to get the path:', {check, name, tail, error});
        throw error;
      }
    }

    /**
     * Extend collections. Create DocPad's
     * standard (documents, files
     * layouts) and special (generate, referencesOthers,
     * hasLayout, html, stylesheet) collections. Set blocks
     * @private
     * @method extendCollections
     * @param {Function} next
     * @param {Error} next.err
     */
    extendCollections(next) {
      var database, docpad, docpadConfig, locale, tasks;
      // Prepare
      docpad = this;
      docpadConfig = this.getConfig();
      locale = this.getLocale();
      database = this.getDatabase();
      // Standard Collections
      this.setCollections({
        // Standard Collections
        documents: database.createLiveChildCollection().setQuery('isDocument', {
          render: true,
          write: true
        }).on('add', function(model) {
          return docpad.log('debug', util.format(locale.addingDocument, model.getFilePath()));
        }),
        files: database.createLiveChildCollection().setQuery('isFile', {
          render: false,
          write: true
        }).on('add', function(model) {
          return docpad.log('debug', util.format(locale.addingFile, model.getFilePath()));
        }),
        layouts: database.createLiveChildCollection().setQuery('isLayout', {
          $or: {
            isLayout: true,
            fullPath: {
              $startsWith: this.getPath('layouts')
            }
          }
        }).on('add', function(model) {
          docpad.log('debug', util.format(locale.addingLayout, model.getFilePath()));
          return model.setDefaults({
            isLayout: true,
            render: false,
            write: false
          });
        }),
        // Special Collections
        generate: database.createLiveChildCollection().setQuery('generate', {
          ignored: false
        }).on('add', function(model) {
          return docpad.log('debug', util.format(locale.addingGenerate, model.getFilePath()));
        }),
        referencesOthers: database.createLiveChildCollection().setQuery('referencesOthers', {
          ignored: false,
          referencesOthers: true
        }).on('add', function(model) {
          return docpad.log('debug', util.format(locale.addingReferencesOthers, model.getFilePath()));
        }),
        hasLayout: database.createLiveChildCollection().setQuery('hasLayout', {
          ignored: false,
          layout: {
            $exists: true
          }
        }).on('add', function(model) {
          return docpad.log('debug', util.format(locale.addingHasLayout, model.getFilePath()));
        }),
        html: database.createLiveChildCollection().setQuery('isHTML', {
          write: true,
          outExtension: 'html'
        }).on('add', function(model) {
          return docpad.log('debug', util.format(locale.addingHtml, model.getFilePath()));
        }),
        stylesheet: database.createLiveChildCollection().setQuery('isStylesheet', {
          write: true,
          outExtension: 'css'
        })
      });
      // Blocks
      this.setBlocks({
        meta: new MetaCollection(),
        scripts: new ScriptsCollection(),
        styles: new StylesCollection()
      });
      // Custom Collections Group
      tasks = this.createTaskGroup("extendCollections tasks", {
        concurrency: 0
      }).done(function(err) {
        if (err) {
          docpad.error(err);
        }
        return docpad.emitSerial('extendCollections', next);
      });
      // Cycle through Custom Collections
      eachr(docpadConfig.collections || {}, function(fn, name) {
        var err;
        if (!name || !typeChecker.isString(name)) {
          err = new Errlop(`Inside your DocPad configuration you have a custom collection with an invalid name of: ${docpad.inspect(name)}`);
          docpad.error(err);
          return;
        }
        if (!fn || !typeChecker.isFunction(fn)) {
          err = new Errlop(`Inside your DocPad configuration you have a custom collection called ${docpad.inspect(name)} with an invalid method of: ${docpad.inspect(fn)}`);
          docpad.error(err);
          return;
        }
        return tasks.addTask(`creating the custom collection: ${name}`, function(complete) {
          // Init
          return ambi(unbounded.binder.call(fn, docpad), database, function(err, collection) {
            // Check for error
            if (err) {
              docpad.error(err);
              return complete();
            // Check the type of the collection
            } else if (!(collection instanceof QueryCollection)) {
              docpad.warn(util.format(locale.errorInvalidCollection, name));
              return complete();
            }
            if (collection) {
              // Make it a live collection
              collection.live(true);
            }
            // Apply the collection
            docpad.setCollection(name, collection);
            return complete();
          });
        });
      });
      // Run Custom collections
      tasks.run();
      return this;
    }

    /**
     * Reset collections. Perform a complete clean of our collections
     * @private
     * @method resetCollections
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    resetCollections(opts, next) {
      var database, docpad, meta, scripts, styles;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      database = docpad.getDatabase();
      // Make it as if we have never generated before
      docpad.generated = false;
      // Perform a complete clean of our collections
      database.reset([]);
      meta = this.getBlock('meta').reset([]);
      scripts = this.getBlock('scripts').reset([]);
      styles = this.getBlock('styles').reset([]);
      if (docpad.getConfig().poweredByDocPad !== false) {
        // ^ Backbone.js v1.1 changes the return values of these, however we change that in our Element class
        // because if we didn't, all our projects would fail

        // Add default block entries
        meta.add(`<meta name="generator" content="DocPad v${docpad.getVersion()}" />`);
      }
      // Chain
      next();
      return this;
    }

    /**
     * Initialise git repo
     * @private
     * @method initGitRepo
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.results
     */
    initGitRepo(opts, next) {
      var config, docpad;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      // Extract
      opts.stdio = 'inherit';
      if (opts.cwd == null) {
        opts.cwd = this.getPath('root');
      }
      // Forward
      safeps.initGitRepo(opts, next);
      return this;
    }

    /**
     * Init node modules
     * @private
     * @method initNodeModules
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.results
     */
    initNodeModules(opts, next) {
      var command, config, docpad;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      // Extract
      opts.stdio = 'inherit';
      if (opts.cwd == null) {
        opts.cwd = this.getPath('root');
      }
      if (opts.args == null) {
        opts.args = [];
      }
      // Command
      command = ['npm', 'install'];
      command.push(...opts.args);
      // Log
      docpad.log('info', command.join(' '));
      // Forward
      safeps.spawn(command, opts, next);
      return this;
    }

    /**
     * Fix node package versions
     * Combat to https://github.com/npm/npm/issues/4587#issuecomment-35370453
     * @private
     * @method fixNodePackageVersions
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    fixNodePackageVersions(opts, next) {
      var config, docpad;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      // Extract
      if (opts.packagePath == null) {
        opts.packagePath = this.getPath('package');
      }
      // Read and replace
      safefs.readFile(opts.packagePath, function(err, buffer) {
        var data;
        data = buffer.toString();
        data = data.replace(/("docpad(?:.*?)": ")\^/g, '$1~');
        return safefs.writeFile(opts.packagePath, data, function(err) {
          return next(err);
        });
      });
      return this;
    }

    /**
     * Install node module. Same as running
     * 'npm install' through the command line
     * @private
     * @method installNodeModule
     * @param {Array} names
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.result
     */
    installNodeModule(names, opts, next) {
      var command, config, docpad;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      // Extract
      opts.stdio = 'inherit';
      if (opts.cwd == null) {
        opts.cwd = this.getPath('root');
      }
      if (opts.args == null) {
        opts.args = [];
      }
      if (opts.global) {
        opts.save = [];
      }
      if (opts.save === true) {
        opts.save = ['--save'];
      }
      if (opts.save && Array.isArray(opts.save) === false) {
        opts.save = [opts.save];
      }
      // Command
      command = ['npm', 'install'];
      if (!typeChecker.isArray(names)) {
        // Names
        names = names.split(/[,\s]+/);
      }
      names.forEach(function(name) {
        // Check
        if (!name) {
          return;
        }
        if (name.indexOf('@') === -1) {
          // Ensure latest if version isn't specfied
          name += '@latest';
        }
        // Push the name to the commands
        return command.push(name);
      });
      // Arguments
      command.push(...opts.args);
      if (opts.save && opts.save.length) {
        command.push(...opts.save);
      }
      if (opts.global) {
        command.push('--global');
      }
      if (opts.output) {
        // Log
        docpad.log('info', command.join(' '));
      }
      // Forward
      safeps.spawn(command, opts, next);
      return this;
    }

    /**
     * Uninstall node module. Same as running
     * 'npm uninstall' through the command line
     * @private
     * @method uninstallNodeModule
     * @param {Array} names
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.result
     */
    uninstallNodeModule(names, opts, next) {
      var command, config, docpad;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      // Extract
      opts.stdio = 'inherit';
      if (opts.cwd == null) {
        opts.cwd = this.getPath('root');
      }
      if (opts.args == null) {
        opts.args = [];
      }
      if (opts.save === true) {
        opts.save = ['--save', '--save-dev'];
      }
      if (opts.save && Array.isArray(opts.save) === false) {
        opts.save = [opts.save];
      }
      // Command
      command = ['npm', 'uninstall'];
      if (!typeChecker.isArray(names)) {
        // Names
        names = names.split(/[,\s]+/);
      }
      command.push(...names);
      // Arguments
      command.push(...opts.args);
      if (opts.save) {
        command.push(...opts.save);
      }
      // Log
      docpad.log('info', command.join(' '));
      // Forward
      safeps.spawn(command, opts, next);
      return this;
    }

    // =================================
    // Logging
    /**
     * Get the log level
     * @method getLogLevel
     * @return {Number} the log level
     */
    getLogLevel() {
      return this.getConfig().logLevel;
    }

    /**
     * Are we debugging?
     * @method getDebugging
     * @return {Boolean}
     */
    getDebugging() {
      var config;
      config = this.getConfig();
      return config.logLevel === 7 || config.debug;
    }

    /**
     * Check Request
     * @private
     * @method checkRequest
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.res
     */
    checkRequest(next) {
      if (next == null) {
        next = this.error.bind(this);
      }
      return function(err, res) {
        var ref, ref1;
        if (err) {
          // Check
          return next(err, res);
        }
        // Check
        if (((ref = res.body) != null ? ref.success : void 0) === false || ((ref1 = res.body) != null ? ref1.error : void 0)) {
          err = new Errlop(res.body.error || 'unknown request error');
          return next(err, res);
        }
        // Success
        return next(null, res);
      };
    }

    /**
     * Send a notify event to plugins (like growl)
     * @method notify
     * @param {String} message
     * @param {Object} [opts={}]
     */
    notify(message, opts = {}) {
      var docpad;
      // Prepare
      docpad = this;
      // Emit
      docpad.emitSerial('notify', {message, opts}, function(err) {
        if (err) {
          return docpad.error(err);
        }
      });
      return this;
    }

    /**
     * Inspect. Converts object to JSON string. Wrapper around nodes util.inspect method.
     * Can't use the inspect namespace as for some silly reason it destroys everything
     * @method inspect
     * @param {Object} obj
     * @param {Object} opts
     * @return {String} JSON string of passed object
     */
    inspect(obj, opts) {
      if (opts == null) {
        opts = {};
      }
      if (opts.colors == null) {
        opts.colors = this.getConfig().color;
      }
      return util.inspect(obj, opts);
    }

    /**
     * Log arguments to
     * @property {Object} log
     * @param {Mixed} args...
     */
    log(...args) {
      var logLevel, logLevels, logger, ref;
      // Log
      logger = this.getLogger();
      if ((logger != null ? logger.log : void 0) != null) {
        logger.log.apply(logger, args);
      } else {
        // logger doesn't exist, this is probably because it was destroyed
        // so handle the most basic case ourselves
        // that case being when the first argument is a log level string
        // as we don't want to interpret log(new Date().getTime()) as a log level number
        // @todo
        // ideally, this logic would be static methods inside caterpillar
        // as caterpillar methods is already where this logic exist, they just have to be made static
        logLevels = require('rfc-log-levels');
        logLevel = (ref = logLevels[args[0]]) != null ? ref : 6;
        if (this.getLogLevel() >= logLevel) {
          console.log(...args);
        }
      }
      return this;
    }

    /**
     * Create an error and log it
     * This is called by all sorts of things, including docpad.warn
     * As such, the err.level is important
     * @method error
     * @param {*} value
     * @return {Error}
     */
    error(value) {
      var err, locale, title;
      // Prepare
      locale = this.getLocale();
      // Ensure it is an error
      err = Errlop.ensure(value);
      if (err.level == null) {
        err.level = 'error';
      }
      if (err.log == null) {
        err.log = true;
      }
      if (err.logged == null) {
        err.logged = false;
      }
      if (err.notify == null) {
        err.notify = true;
      }
      if (err.notified == null) {
        err.notified = false;
      }
      if (err.report == null) {
        err.report = err.level !== 'warn';
      }
      // Set the exit code
      this.exitCode(err);
      // Log the error
      if (err.log !== false && err.logged !== true) {
        err.logged = true;
        this.log(err.logLevel || err.level, err.stack + (err.report && ('\n' + locale.errorSubmission) || ''));
      }
      // Notify the error
      if (err.notify !== false && err.notified !== true) {
        err.notified = true;
        title = locale[err.level + 'Occured'] || locale.errorOccured;
        this.notify(err.message, {title});
      }
      // Return the result error
      return err;
    }

    /**
     * Log an error of level 'warn'
     * @method warn
     * @param {*} value
     * @return {Error}
     */
    warn(value) {
      var err;
      err = Errlop.ensure(value);
      if (err.level == null) {
        err.level = 'warn';
      }
      // Foward
      return this.error(err);
    }

    /**
     * Handle a fatal error
     * @private
     * @method fatal
     * @param {*} value
     * @param {Function} [next]
     * @return {Error}
     */
    fatal(value, next) {
      var err;
      if (!value) {
        // Check
        return this;
      }
      // Enforce errlop with fatal level
      err = new Errlop('A fatal error occured within DocPad', value);
      err.level = 'fatal';
      err.logLevel = 'critical';
      // Handle
      this.error(err);
      // Set the exit code if we are allowed to
      this.exitCode(err);
      // Destroy DocPad
      this.destroy({}, next);
      // Return the error
      return err;
    }

    /**
     * Sets the exit code if we are allowed to, and if it hasn't already been set
     * @method exitCode
     * @param {number|Error [input]
     * @return {number}
     */
    exitCode(input) {
      var because, code, error, exitCode, level, message, originalExitCode, setExitCodeOnError, setExitCodeOnFatal, setExitCodeOnRequest;
      // Determine if necessary
      if (!process.exitCode) {
        // Prepare
        ({setExitCodeOnRequest, setExitCodeOnError, setExitCodeOnFatal} = this.getConfig());
        // Number
        if (typeChecker.isNumber(input)) {
          code = input;
          level = null;
        // Error
        } else if (input instanceof Error) {
          code = input.exitCode;
          level = input.level || null;
          error = input;
        }
        if (!code || isNaN(Number(code))) {
          exitCode = 1;
        } else {
          exitCode = code;
        }
        // Determine desire
        because = (!level && setExitCodeOnRequest && 'requested') || (level === 'fatal' && setExitCodeOnFatal && 'fatal') || (level === 'error' && setExitCodeOnFatal && 'error');
        if (because) {
          // Fetch before we apply so we can log it shortly
          originalExitCode = process.exitCode || 'unset';
          // Apply
          process.exitCode = exitCode;
          // And log it
          message = ['Set the exit code from', originalExitCode, 'to', exitCode, 'because of', because];
          if (error && error.message) {
            message.push('from:', error.message);
          }
          this.log('note', ...message);
        }
      }
      // Return the application
      return process.exitCode;
    }

    // =================================
    // Models and Collections

      // ---------------------------------
    // b/c compat functions
    /**
     * Create file model. Calls
     * {{#crossLink "DocPad/createModel:method"}}{{/crossLink}}
     * with the 'file' modelType.
     * @method createFile
     * @param {Object} [attrs={}]
     * @param {Object} [opts={}]
     * @return {Object} FileModel
     */
    createFile(attrs = {}, opts = {}) {
      opts.modelType = 'file';
      return this.createModel(attrs, opts);
    }

    /**
     * Create document model. Calls
     * {{#crossLink "DocPad/createModel:method"}}{{/crossLink}}
     * with the 'document' modelType.
     * @method createDocument
     * @param {Object} [attrs={}]
     * @param {Object} [opts={}]
     * @return {Object} DocumentModel
     */
    createDocument(attrs = {}, opts = {}) {
      opts.modelType = 'document';
      return this.createModel(attrs, opts);
    }

    /**
     * Parse the files directory and
     * return a files collection to
     * the passed callback
     * @method parseFileDirectory
     * @param {Object} [opts={}]
     * @param {Function} next callback
     * @param {Error} next.err
     * @param {Object} next.files files collection
     */
    parseFileDirectory(opts, next) {
      [opts, next] = extractOptsAndCallback(opts, next);
      if (opts.modelType == null) {
        opts.modelType = 'file';
      }
      if (opts.collection == null) {
        opts.collection = this.getDatabase();
      }
      return this.parseDirectory(opts, next);
    }

    /**
     * Parse the documents directory and
     * return a documents collection to
     * the passed callback.
     *
     * The partials plugin (https://github.com/docpad/docpad-plugin-partials)
     * uses this method to load a collection of
     * files from the partials directory.
     *
     * 	docpad.parseDocumentDirectory({path: config.partialsPath}, next)
     *
     * @method parseDocumentDirectory
     * @param {Object} [opts={}]
     * @param {String} [opts.modelType='document']
     * @param {Object} [opts.collection=docpad.database]
     * @param {Object} [opts.path]
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.files files collection of documents
     */
    parseDocumentDirectory(opts, next) {
      [opts, next] = extractOptsAndCallback(opts, next);
      if (opts.modelType == null) {
        opts.modelType = 'document';
      }
      if (opts.collection == null) {
        opts.collection = this.getDatabase();
      }
      return this.parseDirectory(opts, next);
    }

    // ---------------------------------
    // Standard functions
    /**
     * Attach events to a document model.
     * @private
     * @method attachModelEvents
     * @param {Object} model
     */
    attachModelEvents(model) {
      var docpad;
      // Prepare
      docpad = this;
      // Only attach events if we haven't already done so
      if (model.attachedDocumentEvents !== true) {
        model.attachedDocumentEvents = true;
        // Attach document events
        if (model.type === 'document') {
          // Clone
          model.on('clone', function(clonedModel) {
            return docpad.attachModelEvents(clonedModel);
          });
          // Render
          model.on('render', function(...args) {
            return docpad.emitSerial('render', ...args);
          });
          // Render document
          model.on('renderDocument', function(...args) {
            return docpad.emitSerial('renderDocument', ...args);
          });
          // Fetch a layout
          model.on('getLayout', function(opts, next) {
            var layout;
            opts.collection = docpad.getCollection('layouts');
            layout = docpad.getFileBySelector(opts.selector, opts);
            return next(null, {layout});
          });
        }
        // Remove
        //model.on 'remove', (file) ->
        //	docpad.getDatabase().remove(file)
        // ^ Commented out as for some reason this stops layouts from working

        // Error
        model.on('error', function(...args) {
          return docpad.emit('error', ...args);
        });
        // Log
        model.on('log', function(...args) {
          var ref, ref1;
          // .error and .warn only accept one argument
          // so only forward to them if args length is 2
          if (args.length === 2) {
            if ((ref = args[0]) === 'err' || ref === 'error') {
              docpad.error(args[1]);
              return;
            }
            if ((ref1 = args[0]) === 'warn' || ref1 === 'warning') {
              docpad.warn(args[1]);
              return;
            }
          }
          // otherwise forward to log
          docpad.log(...args);
        });
      }
      return this;
    }

    /**
     * Add supplied model to the DocPad database. If the passed
     * model definition is a plain object of properties, a new
     * model will be created prior to adding to the database.
     * Calls {{#crossLink "DocPad/createModel:method"}}{{/crossLink}}
     * before adding the model to the database.
     *
     *	# Override the stat's mtime to now
     *	# This is because renames will not update the mtime
     *	fileCurrentStat?.mtime = new Date()
     *
     *	# Create the file object
     *	file = docpad.addModel({fullPath:filePath, stat:fileCurrentStat})
     *
     * @method addModel
     * @param {Object} model either a plain object defining the required properties, in particular
     * the file path or an actual model object
     * @param {Object} opts
     * @return {Object} the model
     */
    addModel(model, opts) {
      model = this.createModel(model, opts);
      this.getDatabase().add(model);
      return model;
    }

    /**
     * Add the supplied collection of models to the DocPad database.
     * Calls {{#crossLink "DocPad/createModels:method"}}{{/crossLink}}
     * before adding the models to the database.
     *
     * 	databaseData = JSON.parse data.toString()
     *	models = docpad.addModels(databaseData.models)
     *
     * @method addModels
     * @param {Object} models DocPad collection of models
     * @param {Object} opts
     * @return {Object} the models
     */
    addModels(models, opts) {
      models = this.createModels(models, opts);
      this.getDatabase().add(models);
      return models;
    }

    /**
     * Create a collection of models from the supplied collection
     * ensuring that the collection is suitable for adding to the
     * DocPad database. The method calls {{#crossLink "DocPad/createModel"}}{{/crossLink}}
     * for each model in the models array.
     * @private
     * @method createModels
     * @param {Object} models DocPad collection of models
     * @param {Object} opts
     * @return {Object} the models
     */
    createModels(models, opts) {
      var j, len, model, results;
      results = [];
      for (j = 0, len = models.length; j < len; j++) {
        model = models[j];
        results.push(this.createModel(model, opts));
      }
      return results;
    }

    // return the for loop results
    /**
     * Creates either a file or document model.
     * The model type to be created can be passed
     * as an opts property, if not, the method will
     * attempt to determing the model type by checking
     * if the file is in one of the documents or
     * layout paths.
     *
     * Ensures a duplicate model is not created
     * and all required attributes are present and
     * events attached.
     *
     * Generally it is not necessary for an application
     * to manually create a model via creatModel as DocPad
     * will handle this process when watching a project's
     * file and document directories. However, it is possible
     * that a plugin might have a requirement to do so.
     *
     * 	model = @docpad.createModel({fullPath:fullPath})
     *   model.load()
     *   @docpad.getDatabase().add(model)
     *
     * @method createModel
     * @param {Object} [attrs={}]
     * @param {String} attrs.fullPath the full path to the file
     * @param {Object} [opts={}]
     * @param {String} opts.modelType either 'file' or 'document'
     * @return {Object} the file or document model
     */
    createModel(attrs = {}, opts = {}) {
      var config, database, dirPath, docpad, fileFullPath, j, k, len, len1, model, ref, ref1, result;
      // Check
      if (attrs instanceof FileModel) {
        return attrs;
      }
      // Prepare
      docpad = this;
      config = this.getConfig();
      database = this.getDatabase();
      fileFullPath = attrs.fullPath || null;
      // Find or create
      // This functionality use to be inside ensureModel
      // But that caused duplicates in some instances
      // So now we will always check
      if (attrs.fullPath) {
        result = database.findOne({
          fullPath: attrs.fullPath
        });
        if (result) {
          return result;
        }
      }
      // -----------------------------
      // Try and determine the model type

      // If the type hasn't been specified try and detemrine it based on the full path
      if (fileFullPath) {
        // Check if we have a document or layout
        if (!opts.modelType) {
          ref = this.getPath('documents').concat(this.getPath('layouts')).filter(isTruthy);
          for (j = 0, len = ref.length; j < len; j++) {
            dirPath = ref[j];
            if (fileFullPath.indexOf(dirPath) === 0) {
              attrs.relativePath || (attrs.relativePath = fileFullPath.replace(dirPath, '').replace(/^[\/\\]/, ''));
              opts.modelType = 'document';
              break;
            }
          }
        }
        // Check if we have a file
        if (!opts.modelType) {
          ref1 = this.getPath('files').filter(isTruthy);
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            dirPath = ref1[k];
            if (fileFullPath.indexOf(dirPath) === 0) {
              attrs.relativePath || (attrs.relativePath = fileFullPath.replace(dirPath, '').replace(/^[\/\\]/, ''));
              opts.modelType = 'file';
              break;
            }
          }
        }
      }
      // -----------------------------
      // Create the appropriate emodel

      // Extend the opts with things we need
      opts = extendr.extend({
        detectEncoding: config.detectEncoding,
        rootOutDirPath: this.getPath(false, 'out'),
        locale: this.getLocale(),
        createTaskGroup: this.createTaskGroup // @TODO this a bit dodgy, but works well enough
      }, opts);
      if (opts.modelType === 'file') {
        // Create a file model
        model = new FileModel(attrs, opts);
      } else {
        // Create document model
        model = new DocumentModel(attrs, opts);
      }
      // -----------------------------
      // Finish up

      // Attach Events
      this.attachModelEvents(model);
      // Return
      return model;
    }

    /**
     * Parse a directory and return a
     * files collection
     * @method parseDirectory
     * @param {Object} [opts={}]
     * @param {Object} next
     * @param {Error} next.err
     * @param {Object} next.files files collection
     */
    parseDirectory(opts, next) {
      var createFunction, docpad, files, locale, path;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      locale = this.getLocale();
      // Extract
      ({path, createFunction} = opts);
      if (createFunction == null) {
        createFunction = this.createModel;
      }
      files = opts.collection || new FilesCollection();
      // Check if the directory exists
      safefs.exists(path, function(exists) {
        var tasks;
        // Check
        if (!exists) {
          // Log
          docpad.log('debug', util.format(locale.renderDirectoryNonexistant, path));
          // Forward
          return next();
        }
        // Log
        docpad.log('debug', util.format(locale.renderDirectoryParsing, path));
        // Tasks
        tasks = new TaskGroup('parse directory').setConfig({
          concurrency: 0
        }).done(function(err) {
          if (err) {
            // Check
            return next(err);
          }
          // Log
          docpad.log('debug', util.format(locale.renderDirectoryParsed, path));
          // Forward
          return next(null, files);
        });
        // Files
        return docpad.scandir({
          // Path
          path: path,
          // File Action
          fileAction: function(fileFullPath, fileRelativePath, filename, fileStat) {
            var data, file;
            // Prepare
            data = {
              fullPath: fileFullPath,
              relativePath: fileRelativePath,
              stat: fileStat
            };
            // Create file
            file = createFunction.call(docpad, data, opts);
            // Create a task to load the file
            tasks.addTask(`load the file ${fileRelativePath}`, function(complete) {
              // Update the file's stat
              // To ensure changes files are handled correctly in generation
              return file.action('load', function(err) {
                if (err) {
                  // Error?
                  return complete(err);
                }
                // Add the file to the collection
                files.add(file);
                // Next
                return complete();
              });
            });
          },
          // Next
          // Return
          next: function(err) {
            if (err) {
              return next(err);
            }
            return tasks.run();
          }
        });
      });
      return this;
    }

    // =================================
    // Plugins
    /**
     * Get a plugin by it's name
     * @method getPlugin
     * @param {Object} pluginName
     * @return {Object} a DocPad plugin
     */
    getPlugin(pluginName) {
      return this.loadedPlugins[pluginName];
    }

    /**
     * Check if we have any plugins
     * @method hasPlugins
     * @return {Boolean}
     */
    hasPlugins() {
      return typeChecker.isEmptyPlainObject(this.loadedPlugins) === false;
    }

    /**
     * Destructor. Destroy plugins
     * @private
     * @method destroyPlugins
     */
    destroyPlugins() {
      var name, plugin, ref;
      ref = this.loadedPlugins;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        plugin = ref[name];
        plugin.destroy();
        this.loadedPlugins[name] = null;
      }
      return this;
    }

    /**
     * Load plugins from the file system
     * next(err)
     * @private
     * @method loadPlugins
     * @param {Function} next
     * @param {Error} next.err
     */
    loadPlugins(next) {
      var config, docpad, locale, plugins, tasks;
      // Prepare
      docpad = this;
      config = this.getConfig();
      locale = this.getLocale();
      // Track the slow plugins
      this.slowPlugins = {};
      this.timer('slowplugins', 'interval', config.slowPluginsDelay, function() {
        return docpad.log('notice', util.format(locale.pluginsSlow, Object.keys(docpad.slowPlugins).join(', ')));
      });
      // Async
      tasks = this.createTaskGroup("loadPlugins tasks").done(function(err) {
        docpad.timer('slowplugins');
        docpad.slowPlugins = {};
        return next(err);
      });
      // Prepare the plugins to loaded
      plugins = new Set(Object.keys(docpad.websitePackageConfig.dependencies || {}).concat(Object.keys(docpad.websitePackageConfig.devDependencies || {})).filter(function(name) {
        return name.startsWith('docpad-plugin-');
      }).concat(config.pluginPaths || []).map(function(name) {
        return {
          pluginPath: docpad.getPath(false, 'root', 'node_modules', name)
        };
      }));
      // Emit the even
      tasks.addTask('emit loadPlugins', function(complete) {
        return docpad.emitSerial('loadPlugins', {docpad, plugins}, complete);
      });
      // Load the plugins
      tasks.addTaskGroup('load plugins', {
        concurrency: 0
      }, function(suite, task) {
        return plugins.forEach(function(plugin) {
          return tasks.addTask(`load the plugin at: ${plugin.pluginPath}`, function(complete) {
            return docpad.loadPlugin(plugin, complete);
          });
        });
      });
      // Execute the loading asynchronously
      tasks.run();
      return this;
    }

    /**
     * Load a plugin from its full file path
     * _next(err)
     * @private
     * @method loadPlugin
     * @param {Object} opts
     * @param {Function} _next
     * @param {Error} _next.err
     */
    loadPlugin(opts = {}, _next) {
      var config, docpad, enabled, err, failedError, loader, locale, next, pluginName, unsupportedError;
      // Prepare
      docpad = this;
      config = this.getConfig();
      locale = this.getLocale();
      next = function(err) {
        if (pluginName) {
          // Remove from slow plugins
          delete docpad.slowPlugins[pluginName];
        }
        // Forward
        _next(err);
        // Chain
        return docpad;
      };
      // Default opts
      if (opts.keyword == null) {
        opts.keyword = 'docpad-plugin';
      }
      if (opts.prefix == null) {
        opts.prefix = 'docpad-plugin-';
      }
      if (opts.BasePlugin == null) {
        opts.BasePlugin = BasePlugin;
      }
      if (opts.log == null) {
        opts.log = this.log;
      }
      try {
        // Load and validate the plugin
        loader = new PluginLoader(opts);
      } catch (error1) {
        unsupportedError = error1;
        docpad.warn(new Errlop(util.format(locale.pluginUnsupported, opts.pluginPath), unsupportedError));
        return next();
      }
      // Prepare
      pluginName = loader.pluginName;
      enabled = config.plugins[pluginName] !== false;
      // If we've already been loaded, then exit early as there is no use for us to load again
      if (docpad.loadedPlugins[pluginName] != null) {
        // However we probably want to reload the configuration as perhaps the user or environment configuration has changed
        docpad.loadedPlugins[pluginName].setConfig();
        // Complete
        return next();
      }
      // Add to loading stores
      docpad.slowPlugins[pluginName] = true;
      // Check
      if (!enabled) {
        // Skip
        docpad.log('info', util.format(locale.pluginDisabled, opts.pluginName));
        return next();
      } else {
        // Load
        docpad.log('debug', util.format(locale.pluginLoading, opts.pluginPath));
      }
      try {
        // Add to plugin stores
        // Create an instance
        docpad.loadedPlugins[pluginName] = loader.create({docpad});
      } catch (error1) {
        failedError = error1;
        err = new Errlop(util.format(locale.pluginFailed, opts.pluginPath), failedError);
        return next(err);
      }
      // Log completion
      docpad.log('debug', util.format(locale.pluginLoaded, opts.pluginPath));
      return next();
    }

    // =================================
    // Utilities

      // ---------------------------------
    // Utilities: Files
    /**
     * Contextualize files.
     * Contextualizing is the process of adding layouts and
     * awareness of other documents to our document. The
     * contextualizeBefore and contextualizeAfter events
     * are emitted here.
     * @private
     * @method contextualizeFiles
     * @param {Object} [opts={}]
     * @param {Function} next
     * @param {Error} next.err
     */
    contextualizeFiles(opts, next) {
      var collection, config, docpad, locale, slowFilesObject, templateData;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      ({collection, templateData} = opts);
      docpad = this;
      config = this.getConfig();
      locale = this.getLocale();
      slowFilesObject = {};
      // Log
      docpad.log('debug', util.format(locale.contextualizingFiles, collection.length));
      // Start contextualizing
      docpad.emitSerial('contextualizeBefore', {collection, templateData}, function(err) {
        var tasks;
        if (err) {
          // Prepare
          return next(err);
        }
        // Completion callback
        tasks = docpad.createTaskGroup("contextualizeFiles", {
          concurrency: 0
        }).done(function(err) {
          // Kill the timer
          docpad.timer('slowfiles');
          if (err) {
            // Check
            return next(err);
          }
          // After
          return docpad.emitSerial('contextualizeAfter', {collection}, function(err) {
            if (err) {
              // Check
              return next(err);
            }
            // Log
            docpad.log('debug', util.format(locale.contextualizedFiles, collection.length));
            // Forward
            return next();
          });
        });
        // Add contextualize tasks
        collection.forEach(function(file, index) {
          var filePath;
          filePath = file.getFilePath();
          slowFilesObject[file.id] = file.get('relativePath') || file.id;
          return tasks.addTask(`conextualizing: ${filePath}`, function(complete) {
            return file.action('contextualize', function(err) {
              delete slowFilesObject[file.id];
              return complete(err);
            });
          });
        });
        // Setup the timer
        docpad.timer('slowfiles', 'interval', config.slowFilesDelay, function() {
          var key, slowFilesArray, value;
          slowFilesArray = (function() {
            var results;
            results = [];
            for (key in slowFilesObject) {
              if (!hasProp.call(slowFilesObject, key)) continue;
              value = slowFilesObject[key];
              results.push(value || key);
            }
            return results;
          })();
          return docpad.log('info', util.format(locale.slowFiles, 'contextualizeFiles') + ' \n' + slowFilesArray.join('\n'));
        });
        // Run tasks
        return tasks.run();
      });
      return this;
    }

    /**
     * Render the DocPad project's files.
     * The renderCollectionBefore, renderCollectionAfter,
     * renderBefore, renderAfter events are all emitted here.
     * @private
     * @method renderFiles
     * @param {Object} [opts={}]
     * @param {Function} next
     * @param {Error} next.err
     */
    renderFiles(opts, next) {
      var collection, config, docpad, locale, renderCollection, renderFile, renderPasses, slowFilesObject, templateData;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      ({collection, templateData, renderPasses} = opts);
      docpad = this;
      config = this.getConfig();
      locale = this.getLocale();
      slowFilesObject = {};
      // Log
      docpad.log('debug', util.format(locale.renderingFiles, collection.length));
      // Render File
      // next(null, outContent, file)
      renderFile = function(file, next) {
        // Render
        if (file.get('render') === false || !file.get('relativePath')) {
          file.attributes.rtime = new Date();
          next(null, file.getOutContent(), file);
        } else {
          file.action('render', {templateData}, next);
        }
        // Return
        return file;
      };
      // Render Collection
      renderCollection = function(collectionToRender, {renderPass}, next) {
        // Plugin Event
        return docpad.emitSerial('renderCollectionBefore', {
          collection: collectionToRender,
          renderPass
        }, function(err) {
          var subTasks;
          if (err) {
            // Prepare
            return next(err);
          }
          subTasks = docpad.createTaskGroup(`renderFiles: Pass ${renderPass}]: renderCollection: ${collectionToRender.options.name}`, {
            concurrency: 0
          }).done(function(err) {
            if (err) {
              // Prepare
              return next(err);
            }
            // Plugin Event
            return docpad.emitSerial('renderCollectionAfter', {
              collection: collectionToRender,
              renderPass
            }, next);
          });
          // Cycle
          collectionToRender.forEach(function(file) {
            var filePath;
            filePath = file.getFilePath();
            slowFilesObject[file.id] = file.get('relativePath');
            return subTasks.addTask(`rendering: ${filePath}`, function(complete) {
              return renderFile(file, function(err) {
                delete slowFilesObject[file.id] || file.id;
                return complete(err);
              });
            });
          });
          // Return
          subTasks.run();
          return collectionToRender;
        });
      };
      // Plugin Event
      docpad.emitSerial('renderBefore', {collection, templateData}, function(err) {
        var initialCollection, subsequentCollection, tasks;
        if (err) {
          // Prepare
          return next(err);
        }
        // Async
        tasks = docpad.createTaskGroup("renderFiles: renderCollection: renderBefore").done(function(err) {
          // Kill the timer
          docpad.timer('slowfiles');
          if (err) {
            // Check
            return next(err);
          }
          // After
          return docpad.emitSerial('renderAfter', {collection}, function(err) {
            if (err) {
              // Check
              return next(err);
            }
            // Log
            docpad.log('debug', util.format(locale.renderedFiles, collection.length));
            // Forward
            return next();
          });
        });
        // Queue the initial render
        initialCollection = collection.findAll({
          'referencesOthers': false
        });
        subsequentCollection = null;
        tasks.addTask("rendering the initial collection", function(complete) {
          return renderCollection(initialCollection, {
            renderPass: 1
          }, function(err) {
            if (err) {
              return complete(err);
            }
            subsequentCollection = collection.findAll({
              'referencesOthers': true
            });
            return renderCollection(subsequentCollection, {
              renderPass: 2
            }, complete);
          });
        });
        // Queue the subsequent renders
        if (renderPasses > 1) {
          (function() {
            var results = [];
            for (var j = 3; 3 <= renderPasses ? j <= renderPasses : j >= renderPasses; 3 <= renderPasses ? j++ : j--){ results.push(j); }
            return results;
          }).apply(this).forEach(function(renderPass) {
            return tasks.addTask(`rendering the subsequent collection index ${renderPass}`, function(complete) {
              return renderCollection(subsequentCollection, {renderPass}, complete);
            });
          });
        }
        // Setup the timer
        docpad.timer('slowfiles', 'interval', config.slowFilesDelay, function() {
          var key, slowFilesArray, value;
          slowFilesArray = (function() {
            var results;
            results = [];
            for (key in slowFilesObject) {
              if (!hasProp.call(slowFilesObject, key)) continue;
              value = slowFilesObject[key];
              results.push(value || key);
            }
            return results;
          })();
          return docpad.log('info', util.format(locale.slowFiles, 'renderFiles') + ' \n' + slowFilesArray.join('\n'));
        });
        // Run tasks
        return tasks.run();
      });
      return this;
    }

    /**
     * Write rendered files to the DocPad out directory.
     * The writeBefore and writeAfter events are emitted here.
     * @private
     * @method writeFiles
     * @param {Object} [opts={}]
     * @param {Function} next
     * @param {Error} next.err
     */
    writeFiles(opts, next) {
      var collection, config, docpad, locale, slowFilesObject, templateData;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      ({collection, templateData} = opts);
      docpad = this;
      config = this.getConfig();
      locale = this.getLocale();
      slowFilesObject = {};
      // Log
      docpad.log('debug', util.format(locale.writingFiles, collection.length));
      // Plugin Event
      docpad.emitSerial('writeBefore', {collection, templateData}, function(err) {
        var tasks;
        if (err) {
          // Prepare
          return next(err);
        }
        // Completion callback
        tasks = docpad.createTaskGroup("writeFiles", {
          concurrency: 0
        }).done(function(err) {
          // Kill the timer
          docpad.timer('slowfiles');
          if (err) {
            // Check
            return next(err);
          }
          // After
          return docpad.emitSerial('writeAfter', {collection}, function(err) {
            if (err) {
              // Check
              return next(err);
            }
            // docpad.log 'debug', util.format(locale.wroteFiles, collection.length)
            return next();
          });
        });
        // Add write tasks
        collection.forEach(function(file, index) {
          var filePath;
          filePath = file.getFilePath();
          return tasks.addTask(`writing the file: ${filePath}`, function(complete) {
            var fileTasks;
            // Prepare
            slowFilesObject[file.id] = file.get('relativePath');
            // Create sub tasks
            fileTasks = docpad.createTaskGroup(`tasks for file write: ${filePath}`, {
              concurrency: 0
            }).done(function(err) {
              delete slowFilesObject[file.id];
              return complete(err);
            });
            // Write out
            if (file.get('write') !== false && file.get('outPath')) {
              fileTasks.addTask("write out", function(complete) {
                return file.action('write', complete);
              });
            }
            // Write source
            if (file.get('writeSource') === true && file.get('fullPath')) {
              fileTasks.addTask("write source", function(complete) {
                return file.action('writeSource', complete);
              });
            }
            // Run sub tasks
            return fileTasks.run();
          });
        });
        // Setup the timer
        docpad.timer('slowfiles', 'interval', config.slowFilesDelay, function() {
          var key, slowFilesArray, value;
          slowFilesArray = (function() {
            var results;
            results = [];
            for (key in slowFilesObject) {
              if (!hasProp.call(slowFilesObject, key)) continue;
              value = slowFilesObject[key];
              results.push(value || key);
            }
            return results;
          })();
          return docpad.log('info', util.format(locale.slowFiles, 'writeFiles') + ' \n' + slowFilesArray.join('\n'));
        });
        // Run tasks
        return tasks.run();
      });
      return this;
    }

    /**
     * Set off DocPad's generation process.
     * The generated, populateCollectionsBefore, populateCollections, populateCollections
     * generateBefore and generateAfter events are emitted here
     * @method generate
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    generate(opts, next) {
      var addGroup, addTask, config, database, docpad, lastGenerateStarted, locale, ref, tasks;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = docpad.getConfig();
      locale = docpad.getLocale();
      database = docpad.getDatabase();
      if (((ref = opts.collection) != null ? ref.length : void 0) === 0) {
        // Check
        return next();
      }
      // Update generating flag
      lastGenerateStarted = docpad.generateStarted;
      docpad.generateStarted = new Date();
      docpad.generateEnded = null;
      docpad.generating = true;
      // Grab the template data we will use for rendering
      opts.templateData = docpad.getTemplateData(opts.templateData || {});
      // How many render passes will we require?
      // Can be over-written by API calls
      opts.renderPasses || (opts.renderPasses = config.renderPasses);
      // Destroy Regenerate Timer
      docpad.timer('regenerate');
      if (!docpad.hasPlugins()) {
        // Check plugin count
        docpad.log('notice', locale.renderNoPlugins);
      }
      // Log
      docpad.log('info', locale.renderGenerating);
      docpad.notify((new Date()).toLocaleTimeString(), {
        title: locale.renderGeneratingNotification
      });
      // Tasks
      tasks = this.createTaskGroup("generate tasks").done(function(err) {
        var howMany, ref1, seconds;
        // Update generating flag
        docpad.generating = false;
        docpad.generateEnded = new Date();
        // Create Regenerate Timer
        if (config.regenerateEvery) {
          docpad.timer('regenerate', 'timeout', config.regenerateEvery, function() {
            docpad.log('info', locale.renderInterval);
            return docpad.action('generate', config.regenerateEveryOptions);
          });
        }
        if (err) {
          // Error?
          return next(err);
        }
        // Log success message
        seconds = (docpad.generateEnded - docpad.generateStarted) / 1000;
        howMany = `${((ref1 = opts.collection) != null ? ref1.length : void 0) || 0}/${database.length}`;
        docpad.log('info', util.format(locale.renderGenerated, howMany, seconds));
        docpad.notify((new Date()).toLocaleTimeString(), {
          title: locale.renderGeneratedNotification
        });
        // Generated
        if (opts.initial === true) {
          docpad.generated = true;
          return docpad.emitSerial('generated', opts, next);
        // Safety check if generated is false but initial was false too
        // https://github.com/bevry/docpad/issues/811
        } else if (docpad.generated === false) {
          return next(new Errlop('DocPad is in an invalid state, please report this. Reference 3360'));
        } else {
          return next();
        }
      });
      // Extract functions from tasks for simplicity
      // when dealing with nested tasks/groups
      addGroup = tasks.addGroup.bind(tasks);
      addTask = tasks.addTask.bind(tasks);
      // Setup a clean database
      addTask('Reset our collections', function(complete) {
        if (!(opts.reset === true || docpad.generated === false)) {
          // Skip if we are not a reset generation, or an initial generation (generated is false)
          return complete();
        }
        return docpad.resetCollections(opts, complete);
      });
      // Figure out the options
      // This is here as resetCollections could change our state
      // https://github.com/bevry/docpad/issues/811
      addTask('Figure out options', function() {
        // Mode: Initial
        // Shall we do some basic initial checks
        // Set to the opts.reset value if specified, or whether are the initial generation
        if (opts.initial == null) {
          opts.initial = !docpad.generated;
        }
        // Mode: Reset
        // Shall we reset the database
        // Set to true if we are the initial generation
        if (opts.reset == null) {
          opts.reset = opts.initial;
        }
        // Mode: Populate
        // Shall we fetch in new data?
        // Set to the opts.reset value if specified, or the opts.initial value
        if (opts.populate == null) {
          opts.populate = opts.reset;
        }
        // Mode: Reload
        // Shall we rescan the file system for changes?
        // Set to the opts.reset value if specified, or the opts.initial value
        if (opts.reload == null) {
          opts.reload = opts.reset;
        }
        // Mode: Partial
        // Shall we perform a partial generation (false) or a completion generation (true)?
        // Set to false if we are the initial generation
        if (opts.partial == null) {
          opts.partial = !opts.reset;
        }
        // Log our opts
        return docpad.log('debug', 'Generate options:', pick(opts, ['initial', 'reset', 'populate', 'reload', 'partial', 'renderPasses']));
      });
      // Check directory structure
      addTask('check source directory exists', function(complete) {
        var err, sourcePath;
        if (opts.initial !== true) {
          // Skip if we are not the initial generation
          return complete();
        }
        // Continue if we are the initial generation
        sourcePath = docpad.getPath('source');
        if (!sourcePath) {
          err = new Errlop(util.format(locale.renderNonexistant, docpad.getPath(false, 'source')));
          return complete(err);
        }
        // Forward
        return complete();
      });
      // Check directory structure
      addTask('ensure out directory exists', function(complete) {
        var outPath;
        outPath = docpad.getPath(false, 'out');
        return safefs.ensurePath(outPath, complete);
      });
      addGroup('fetch data to render', function(addGroup, addTask) {
        // Fetch new data
        // If we are a populate generation (by default an initial generation)
        if (opts.populate === true) {
          // This will pull in new data from plugins
          addTask('populateCollectionsBefore', function(complete) {
            return docpad.emitSerial('populateCollectionsBefore', opts, complete);
          });
          // Rescan the file system
          // If we are a reload generation (by default an initial generation)
          // This is useful when the database is out of sync with the source files
          // For instance, someone shut down docpad, and made some changes, then ran docpad again
          // See https://github.com/bevry/docpad/issues/705#issuecomment-29243666 for details
          if (opts.reload === true) {
            addGroup('import data from file system', function(addGroup, addTask) {
              // Documents
              docpad.getPath('documents').forEach(function(documentsPath) {
                return addTask('import documents', function(complete) {
                  return docpad.parseDirectory({
                    modelType: 'document',
                    collection: database,
                    path: documentsPath,
                    next: complete
                  });
                });
              });
              // Files
              docpad.getPath('files').forEach(function(filesPath) {
                return addTask('import files', function(complete) {
                  return docpad.parseDirectory({
                    modelType: 'file',
                    collection: database,
                    path: filesPath,
                    next: complete
                  });
                });
              });
              // Layouts
              return docpad.getPath('layouts').forEach(function(layoutsPath) {
                return addTask('import layouts', function(complete) {
                  return docpad.parseDirectory({
                    modelType: 'document',
                    collection: database,
                    path: layoutsPath,
                    next: complete
                  });
                });
              });
            });
          }
          // This will pull in new data from plugins
          return addTask('populateCollections', function(complete) {
            return docpad.emitSerial('populateCollections', opts, complete);
          });
        }
      });
      addGroup('determine files to render', function(addGroup, addTask) {
        // Perform a complete regeneration
        if (opts.partial === false) {
          // Use Entire Collection
          return addTask('Add all database models to render queue', function() {
            return opts.collection != null ? opts.collection : opts.collection = new FilesCollection().add(docpad.getCollection('generate').models);
          });
        } else {
          // Use Partial Collection
          // Perform a partial regeneration
          // If we are not a reset generation (by default any non-initial generation)
          return addTask('Add only changed models to render queue', function() {
            var changedQuery;
            changedQuery = {
              $or: {
                // Get changed files
                mtime: {
                  $gte: lastGenerateStarted
                },
                // Get new files
                $and: {
                  wtime: null,
                  write: true
                }
              }
            };
            return opts.collection != null ? opts.collection : opts.collection = new FilesCollection().add(docpad.getCollection('generate').findAll(changedQuery).models);
          });
        }
      });
      addTask('generateBefore', function(complete) {
        // If we have nothing to generate
        if (opts.collection.length === 0) {
          // then there is no need to execute further tasks
          tasks.clear();
          return complete();
        } else {
          // Otherwise continue down the task loop
          return docpad.emitSerial('generateBefore', opts, complete);
        }
      });
      addTask('prepare files', function(complete) {
        var addLayoutChildren, allStandalone, model, standalones;
        // Log the files to generate if we are in debug mode
        docpad.log('debug', 'Files to generate at', lastGenerateStarted, '\n', (function() {
          var j, len, ref1, results;
          ref1 = opts.collection.models;
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            model = ref1[j];
            results.push({
              id: model.id,
              path: model.getFilePath(),
              mtime: model.get('mtime'),
              wtime: model.get('wtime'),
              ignored: model.get('ignored'),
              write: model.get('write')
            });
          }
          return results;
        })());
        // Add anything that references other documents (e.g. partials, listing, etc)
        // This could eventually be way better
        standalones = opts.collection.pluck('standalone');
        allStandalone = standalones.indexOf(false) === -1;
        if (allStandalone === false) {
          opts.collection.add(docpad.getCollection('referencesOthers').models);
        }
        // Deeply/recursively add the layout children
        addLayoutChildren = function(collection) {
          return collection.forEach(function(file) {
            var layoutChildrenCollection, layoutChildrenQuery;
            if (file.get('isLayout') === true) {
              // Find
              layoutChildrenQuery = {
                layoutRelativePath: file.get('relativePath')
              };
              layoutChildrenCollection = docpad.getCollection('hasLayout').findAll(layoutChildrenQuery);
              // Log the files to generate if we are in debug mode
              docpad.log('debug', 'Layout children to generate at', lastGenerateStarted, '\n', (function() {
                var j, len, ref1, results;
                ref1 = layoutChildrenCollection.models;
                results = [];
                for (j = 0, len = ref1.length; j < len; j++) {
                  model = ref1[j];
                  results.push({
                    id: model.id,
                    path: model.getFilePath(),
                    mtime: model.get('mtime'),
                    wtime: model.get('wtime'),
                    write: model.get('write')
                  });
                }
                return results;
              })(), '\n', layoutChildrenQuery);
              // Recurse
              addLayoutChildren(layoutChildrenCollection);
              // Add
              return opts.collection.add(layoutChildrenCollection.models);
            }
          });
        };
        addLayoutChildren(opts.collection);
        // Filter out ignored, and no-render no-write files
        opts.collection.reset(opts.collection.reject(function(file) {
          return file.get('render') === false && file.get('write') === false;
        }));
        // Log the files to generate if we are in debug mode
        docpad.log('debug', 'Files to generate at', lastGenerateStarted, '\n', (function() {
          var j, len, ref1, results;
          ref1 = opts.collection.models;
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            model = ref1[j];
            results.push({
              id: model.id,
              path: model.getFilePath(),
              mtime: model.get('mtime'),
              wtime: model.get('wtime'),
              ignored: model.get('ignored'),
              write: model.get('write')
            });
          }
          return results;
        })());
        // Forward
        return complete();
      });
      addGroup('process file', function(addGroup, addTask) {
        addTask('contextualizeFiles', {
          args: [opts]
        }, docpad.contextualizeFiles.bind(docpad));
        addTask('renderFiles', {
          args: [opts]
        }, docpad.renderFiles.bind(docpad));
        return addTask('writeFiles', {
          args: [opts]
        }, docpad.writeFiles.bind(docpad));
      });
      addTask('generateAfter', function(complete) {
        return docpad.emitSerial('generateAfter', opts, complete);
      });
      // Run
      tasks.run();
      return this;
    }

    // ---------------------------------
    // Render
    /**
     * Load a document
     * @private
     * @method loadDocument
     * @param {Object} document
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.document
     */
    loadDocument(document, opts, next) {
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      // Load
      // @TODO: don't load if already loaded
      document.action('load contextualize', opts, next);
      return this;
    }

    /**
     * Load and render a document
     * @method loadAndRenderDocument
     * @param {Object} document
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.document
     */
    loadAndRenderDocument(document, opts, next) {
      var docpad;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      // Load
      docpad.loadDocument(document, opts, function(err) {
        if (err) {
          return next(err);
        }
        // Render
        return docpad.renderDocument(document, opts, next);
      });
      return this;
    }

    /**
     * Render a document
     * @method renderDocument
     * @param {Object} document
     * @param {Object} opts
     * @param {Object} next
     * @param {Error} next.err
     * @param {Object} next.result
     * @param {Object} next.document
     */
    renderDocument(document, opts, next) {
      var clone;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      // Render
      clone = document.clone().action('render', opts, function(err) {
        var result;
        result = clone.getOutContent();
        return next(err, result, document);
      });
      return this;
    }

    /**
     * Render a document at a file path
     * next(err,result)
     * @method renderPath
     * @param {String} path
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.result the rendered document
     */
    renderPath(path, opts, next) {
      var attributes, document;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      attributes = extendr.extend({
        fullPath: path
      }, opts.attributes || {});
      // Handle
      document = this.createDocument(attributes);
      this.loadAndRenderDocument(document, opts, next);
      return this;
    }

    /**
     * Render the passed content data as a
     * document. Required option, filename
     * (opts.filename)
     * next(err,result)
     * @method renderData
     * @param {String} content
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.result the rendered document
     */
    renderData(content, opts, next) {
      var attributes, document;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      attributes = extendr.extend({
        filename: opts.filename,
        data: content
      }, opts.attributes || {});
      // Handle
      document = this.createDocument(attributes);
      this.loadAndRenderDocument(document, opts, next);
      return this;
    }

    // Render Text
    // Doesn't extract meta information, or render layouts
    // TODO: Why not? Why not just have renderData?
    /**
     * Render the passed text data as a
     * document. Required option, filename
     * (opts.filename)
     * next(err,result)
     * @private
     * @method renderText
     * @param {String} text
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     * @param {Object} next.result the rendered content
     * @param {Object} next.document the rendered document model
     */
    renderText(text, opts, next) {
      var attributes, clone, document;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      if (opts.actions == null) {
        opts.actions = ['renderExtensions', 'renderDocument'];
      }
      attributes = extendr.extend({
        filename: opts.filename,
        data: text,
        body: text,
        content: text
      }, opts.attributes || {});
      // Handle
      document = this.createDocument(attributes);
      // Render
      clone = document.clone().action('normalize contextualize render', opts, function(err) {
        var result;
        result = clone.getOutContent();
        return next(err, result, document);
      });
      return this;
    }

    /**
     * Render action
     * @method render
     * @param {Object} opts
     * @param {Object} next
     * @param {Error} next.err
     * @param {Object} next.result
     * @param {Object} next.document
     */
    render(opts, next) {
      var complete, config, docpad, err, locale, path;
      // Prepare
      docpad = this;
      locale = this.getLocale();
      config = this.getConfig();
      [opts, next] = extractOptsAndCallback(opts, next);
      if (opts.stdin == null) {
        opts.stdin = false;
      }
      // Completion
      if (!opts.output) {
        complete = next;
      } else {
        complete = function(err, result, document) {
          if (err) {
            // Forward
            return next(err);
          }
          // Output
          if (opts.output === true) {
            process.stdout.write(result);
          } else if (opts.output) {
            return safefs.writeFile(opts.output, result, function(err) {
              return next(err, result, document);
            });
          }
          // Forward
          return next(null, result, document);
        };
      }
      // Render
      if (opts.stdin) {
        docpad.renderStdin(opts, complete);
      } else if (opts.document) {
        docpad.renderDocument(opts.document, opts, complete);
      } else if (opts.data) {
        docpad.renderData(opts.data, opts, complete);
      } else if (opts.text) {
        docpad.renderText(opts.text, opts, complete);
      } else {
        path = opts.path || opts.fullPath || opts.filename || null;
        if (path) {
          docpad.renderPath(path, opts, complete);
        } else {
          err = new Errlop(locale.renderInvalidOptions);
          return complete(err);
        }
      }
      return this;
    }

    renderStdin(opts, next) {
      var data, docpad, stdin;
      // Prepare
      docpad = this;
      [opts, next] = extractOptsAndCallback(opts, next);
      data = '';
      // Read
      stdin = process.stdin;
      stdin.resume();
      stdin.setEncoding('utf8');
      stdin.on('data', function(_data) {
        docpad.timer('render');
        return data += _data.toString();
      });
      process.stdin.on('end', function() {
        docpad.timer('render');
        return docpad.renderData(data, opts, next);
      });
      return this;
    }

    /**
     * Destructor. Destroy the watchers used
     * by DocPad
     * @private
     * @method destroyWatchers
     */
    destroyWatchers() {
      var docpad, j, len, ref, watcher;
      // Prepare
      docpad = this;
      // Check
      if (docpad.watchers) {
        ref = docpad.watchers;
        // Close each of them
        for (j = 0, len = ref.length; j < len; j++) {
          watcher = ref[j];
          watcher.close();
        }
        // Reset the array
        docpad.watchers = [];
      }
      return this;
    }

    /**
     * Start up file watchers used by DocPad
     * @private
     * @method watch
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    watch(opts, next) {
      var changeHandler, config, database, docpad, locale, performGenerate, queueRegeneration, restartWatchers;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      locale = this.getLocale();
      database = this.getDatabase();
      if (this.watchers == null) {
        this.watchers = [];
      }
      // Restart our watchers
      restartWatchers = function(next) {
        var regeneratePaths, reloadPaths, sourcePaths, tasks;
        // Close our watchers
        docpad.destroyWatchers();
        // Start a group
        tasks = docpad.createTaskGroup("watch tasks", {
          concurrency: 0
        }).done(next);
        // Watch reload paths
        reloadPaths = union(docpad.getPath('reloads'), docpad.getPath('configs'));
        tasks.addTask("watch reload paths", function(complete) {
          return docpad.watchdirs(reloadPaths, {
            'log': docpad.log,
            'error': docpad.error,
            'change': function() {
              docpad.log('info', util.format(locale.watchReloadChange, new Date().toLocaleTimeString()));
              return docpad.action('load', function(err) {
                if (err) {
                  return docpad.fatal(err);
                }
                return performGenerate({
                  reset: true
                });
              });
            }
          }, function(err, _watchers) {
            var j, len, watcher;
            if (err) {
              docpad.warn("Watching the reload paths has failed:\n" + docpad.inspect(reloadPaths), err);
              return complete();
            }
            for (j = 0, len = _watchers.length; j < len; j++) {
              watcher = _watchers[j];
              docpad.watchers.push(watcher);
            }
            return complete();
          });
        });
        // Watch regenerate paths
        regeneratePaths = docpad.getPath('regenerates');
        tasks.addTask("watch regenerate paths", function(complete) {
          return docpad.watchdirs(regeneratePaths, {
            'log': docpad.log,
            'error': docpad.error,
            'change': function() {
              return performGenerate({
                reset: true
              });
            }
          }, function(err, _watchers) {
            var j, len, watcher;
            if (err) {
              docpad.warn("Watching the regenerate paths has failed:\n" + docpad.inspect(regeneratePaths), err);
              return complete();
            }
            for (j = 0, len = _watchers.length; j < len; j++) {
              watcher = _watchers[j];
              docpad.watchers.push(watcher);
            }
            return complete();
          });
        });
        // Watch the source
        sourcePaths = docpad.getPath('sources');
        tasks.addTask("watch the source path", function(complete) {
          return docpad.watchdirs(sourcePaths, {
            'log': docpad.log,
            'error': docpad.error,
            'change': changeHandler
          }, function(err, _watchers) {
            var j, len, watcher;
            if (err) {
              docpad.warn("Watching the source paths has failed:\n" + docpad.inspect(sourcePaths), err);
              return complete();
            }
            for (j = 0, len = _watchers.length; j < len; j++) {
              watcher = _watchers[j];
              docpad.watchers.push(watcher);
            }
            return complete();
          });
        });
        // Run
        tasks.run();
        return this;
      };
      // Timer
      queueRegeneration = function() {
        return docpad.timer('regeneration', 'timeout', config.regenerateDelay, performGenerate);
      };
      // Generate
      performGenerate = function(opts = {}) {
        // Q: Should we also pass over the collection?
        // A: No, doing the mtime query in generate is more robust

        // Log
        docpad.log(util.format(locale.watchRegenerating, new Date().toLocaleTimeString()));
        // Afterwards, re-render anything that should always re-render
        return docpad.action('generate', opts, function(err) {
          if (err) {
            docpad.error(err);
          }
          return docpad.log(util.format(locale.watchRegenerated, new Date().toLocaleTimeString()));
        });
      };
      // Change event handler
      changeHandler = function(changeType, filePath, fileCurrentStat, filePreviousStat) {
        var err, file, fileEitherStat, isDirectory, isIgnored;
        // Prepare
        fileEitherStat = fileCurrentStat || filePreviousStat;
        // For some reason neither of the stats may exist, this will cause errors as this is an invalid state
        // as we depend on at least one stat existing, otherwise, what on earth is going on?
        // Whatever the case, this should be fixed within watchr, not docpad
        // as watchr should not be giving us invalid data
        // https://github.com/bevry/docpad/issues/792
        if (!fileEitherStat) {
          err = new Errlop(`DocPad has encountered an invalid state while detecting changes for your files.
So the DocPad team can fix this right away, please provide any information you can to:
https://github.com/bevry/docpad/issues/792`);
          return docpad.error(err);
        }
        // Log the change
        docpad.log('info', util.format(locale.watchChange, new Date().toLocaleTimeString()), changeType, filePath);
        // Check if we are a file we don't care about
        // This check should not be needed with v2.3.3 of watchr
        // however we've still got it here as it may still be an issue
        isIgnored = docpad.isIgnoredPath(filePath);
        if (isIgnored) {
          docpad.log('debug', util.format(locale.watchIgnoredChange, new Date().toLocaleTimeString()), filePath);
          return;
        }
        // Don't care if we are a directory
        isDirectory = fileEitherStat.isDirectory();
        if (isDirectory) {
          docpad.log('debug', util.format(locale.watchDirectoryChange, new Date().toLocaleTimeString()), filePath);
          return;
        }
        // Override the stat's mtime to now
        // This is because renames will not update the mtime
        if (fileCurrentStat != null) {
          fileCurrentStat.mtime = new Date();
        }
        // Create the file object
        file = docpad.addModel({
          fullPath: filePath,
          stat: fileCurrentStat
        });
        if (changeType === 'update') {
          file.setStat(fileCurrentStat);
        }
        // File was deleted, delete the rendered file, and remove it from the database
        if (changeType === 'delete') {
          database.remove(file);
          return file.action('delete', function(err) {
            if (err) {
              return docpad.error(err);
            }
            return queueRegeneration();
          });
        // File is new or was changed, update it's mtime by setting the stat
        } else if (changeType === 'create' || changeType === 'update') {
          return file.action('load', function(err) {
            if (err) {
              return docpad.error(err);
            }
            return queueRegeneration();
          });
        }
      };
      // Watch
      docpad.log(locale.watchStart);
      restartWatchers(function(err) {
        if (err) {
          return next(err);
        }
        docpad.log(locale.watchStarted);
        return next();
      });
      return this;
    }

    // ---------------------------------
    // Run Action
    /**
     * Run an action
     * @method run
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    run(opts, next) {
      var config, docpad, locale, rootPath, run, sourcePath;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      locale = this.getLocale();
      config = this.getConfig();
      // Prepare
      run = function(next) {
        return docpad.emitSerial('runBefore', function(err) {
          if (err) {
            return next(err);
          }
          return balUtil.flow({
            object: docpad,
            action: 'generate watch',
            args: [opts],
            next: function(err) {
              return docpad.emitSerial('runAfter', next);
            }
          });
        });
      };
      // Check if have the correct structure, if so let's proceed with DocPad
      sourcePath = this.getPath('source');
      if (sourcePath) {
        return run(next);
      }
      // We don't have the correct structure
      // Check if we are running on an empty directory
      rootPath = this.getPath('root');
      safefs.readdir(rootPath, function(err, files) {
        if (err) {
          return next(err);
        }
        // Check if our directory is empty
        if (files.length) {
          // It isn't empty, display a warning
          docpad.warn(util.format(locale.invalidProject, rootPath));
          return next();
        } else {
          return docpad.init(opts, function(err) {
            if (err) {
              // Check
              return next(err);
            }
            if (opts.global === true || docpad.getConfig().global === true) {
              // Keep in global?
              return run(next);
            }
            // Log
            docpad.log('notice', locale.startLocal);
            // Destroy our DocPad instance so we can boot the local one
            return docpad.destroy(function(err) {
              if (err) {
                // Check
                return next(err);
              }
              // Forward onto the local DocPad Instance now that it has been installed
              return docpadUtil.startLocalDocPadExecutable(next);
            });
          });
        }
      });
      return this;
    }

    /**
     * Info action
     * @private
     * @method info
     * @param {Object} opts
     * @param {Function} next
     */
    info(opts, next) {
      [opts, next] = extractOptsAndCallback(opts, next);
      console.log(this.inspect(this.getConfig()));
      if (typeof next === "function") {
        next();
      }
      return this;
    }

    // ---------------------------------
    // Project
    /**
     * Initialize the project install process.
     * @private
     * @method initInstall
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    initInstall(opts, next) {
      var config, docpad, packagePath;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      // Exists?
      packagePath = this.getPath(false, 'package');
      safefs.exists(packagePath, function(exists) {
        var data;
        if (exists) {
          // Check
          return next();
        }
        // Write
        data = JSON.stringify({
          name: 'no-skeleton.docpad',
          version: '0.1.0',
          description: 'New DocPad project without using a skeleton',
          dependencies: {
            docpad: '~' + docpad.getVersion()
          },
          scripts: {
            start: 'docpad run',
            test: 'docpad generate'
          }
        }, null, '  ');
        return safefs.writeFile(packagePath, data, next);
      });
      return this;
    }

    /**
     * Uninstall a plugin.
     * @private
     * @method uninstall
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    uninstall(opts, next) {
      var config, docpad, tasks;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      // Tasks
      tasks = this.createTaskGroup("uninstall tasks").done(next);
      // Uninstall a plugin
      if (opts.plugin) {
        tasks.addTask(`uninstall the plugin: ${opts.plugin}`, function(complete) {
          var plugin, plugins;
          plugins = (function() {
            var j, len, ref, results;
            ref = opts.plugin.split(/[,\s]+/);
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              plugin = ref[j];
              if (plugin.indexOf('docpad-plugin-') !== 0) {
                plugin = `docpad-plugin-${plugin}`;
              }
              results.push(plugin);
            }
            return results;
          })();
          return docpad.uninstallNodeModule(plugins, complete);
        });
      }
      // Re-load configuration
      tasks.addTask("re-load configuration", function(complete) {
        return docpad.load(complete);
      });
      // Run
      tasks.run();
      return this;
    }

    /**
     * Install a plugin
     * @private
     * @method install
     * @param {Object} opts
     * @param {Function} next
     * @param {Error} next.err
     */
    install(opts, next) {
      var config, docpad, tasks;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      // Tasks
      tasks = this.createTaskGroup("install tasks").done(next);
      tasks.addTask("init the installation", function(complete) {
        return docpad.initInstall(opts, complete);
      });
      // Install a plugin
      if (opts.plugin) {
        tasks.addTask(`install the plugin: ${opts.plugin}`, function(complete) {
          var plugin, plugins;
          plugins = (function() {
            var j, len, ref, results;
            ref = opts.plugin.split(/[,\s]+/);
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              plugin = ref[j];
              if (plugin.indexOf('docpad-plugin-') !== 0) {
                plugin = `docpad-plugin-${plugin}`;
              }
              if (plugin.indexOf('@') === -1) {
                plugin += '@' + docpad.pluginVersion;
              }
              results.push(plugin);
            }
            return results;
          })();
          return docpad.installNodeModule(plugins, complete);
        });
      }
      tasks.addTask("re-initialize the website's modules", function(complete) {
        return docpad.initNodeModules(complete);
      });
      tasks.addTask("fix node package versions", function(complete) {
        return docpad.fixNodePackageVersions(complete);
      });
      tasks.addTask("re-load the configuration", function(complete) {
        return docpad.load(complete);
      });
      // Run
      tasks.run();
      return this;
    }

    /**
     * Update global NPM and DocPad
     * @private
     * @method upgrade
     * @param {Object} opts
     * @param {Object} next
     * @param {Error} next.err
     * @return {Object} description
     */
    upgrade(opts, next) {
      // Update Global NPM and DocPad
      this.installNodeModule('npm docpad@6', {
        global: true
      }, next);
      return this;
    }

    /**
     * Update the local DocPad and plugin dependencies
     * @private
     * @method update
     * @param {Object} opts
     * @param {Object} next
     * @param {Error} next.err
     */
    update(opts, next) {
      var config, dependencies, devDependencies, docpad, tasks;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      // Tasks
      tasks = this.createTaskGroup("update tasks").done(next);
      tasks.addTask("init the install", function(complete) {
        return docpad.initInstall(opts, complete);
      });
      // Update the local docpad and plugin dependencies
      // Grouped together to avoid npm dependency shortcuts that can cause missing dependencies
      // But don't update git/http/https dependencies, those are special for some reason
      // > https://github.com/bevry/docpad/pull/701
      dependencies = [];
      eachr(docpad.websitePackageConfig.dependencies, function(version, name) {
        if (/^docpad-plugin-/.test(name) === false || /:\/\//.test(version) === true) {
          return;
        }
        return dependencies.push(name + '@' + docpad.pluginVersion);
      });
      if (dependencies.length !== 0) {
        tasks.addTask("update plugins that are dependencies", function(complete) {
          return docpad.installNodeModule('docpad@6 ' + dependencies, complete);
        });
      }
      // Update the plugin dev dependencies
      devDependencies = [];
      eachr(docpad.websitePackageConfig.devDependencies, function(version, name) {
        if (/^docpad-plugin-/.test(name) === false) {
          return;
        }
        return devDependencies.push(name + '@' + docpad.pluginVersion);
      });
      if (devDependencies.length !== 0) {
        tasks.addTask("update plugins that are dev dependencies", function(complete) {
          return docpad.installNodeModule(devDependencies, {
            save: '--save-dev'
          }, complete);
        });
      }
      tasks.addTask("fix node package versions", function(complete) {
        return docpad.fixNodePackageVersions(complete);
      });
      tasks.addTask("re-initialize the rest of the website's modules", function(complete) {
        return docpad.initNodeModules(complete);
      });
      // Run
      tasks.run();
      return this;
    }

    /**
     * DocPad cleanup tasks.
     * @private
     * @method clean
     * @param {Object} opts
     * @param {Object} next
     * @param {Error} next.err
     * @return {Object} description
     */
    clean(opts, next) {
      var config, docpad, locale, paths, tasks;
      // Prepare
      [opts, next] = extractOptsAndCallback(opts, next);
      docpad = this;
      config = this.getConfig();
      locale = this.getLocale();
      paths = [];
      // Log
      docpad.log('info', locale.cleanStarted);
      // Tasks
      tasks = this.createTaskGroup("clean tasks", {
        concurrency: 0
      }).done(function(err) {
        var message;
        if (err) {
          // Error?
          return next(err);
        }
        // Log
        message = util.format(locale.cleanFinish, paths.length);
        if (paths.length) {
          message += ': ';
          if (paths.length !== 1) {
            message += '\n';
          }
          message += paths.join('\n');
        }
        docpad.log('info', message);
        // Forward
        return next();
      });
      tasks.addTask('reset the collections', function(complete) {
        return docpad.resetCollections(opts, complete);
      });
      // Delete out path
      // but only if our outPath is not a parent of our rootPath
      tasks.addTask('delete out path', function(complete) {
        var outPath, rootPath;
        rootPath = docpad.getPath('root');
        outPath = docpad.getPath('out');
        // Only remove outpath if it does not contain our root path
        if (outPath && pathUtil.relative(outPath, rootPath).startsWith('..')) {
          paths.push(outPath);
          return rimraf(outPath, complete);
        } else {
          return complete();
        }
      });
      // Run tasks
      tasks.run();
      return this;
    }

    /**
     * Initialize the directory for DocPad
     * @private
     * @method init
     * @param {Function} next
     * @param {Error} next.err
     */
    init(opts, next) {
      var config, docpad, rootPath, tasks;
      // Prepare
      docpad = this;
      config = this.getConfig();
      rootPath = this.getPath(false, 'root');
      // Tasks
      tasks = this.createTaskGroup("init tasks").done(next);
      tasks.addTask("ensure the path we are writing to exists", function(complete) {
        return safefs.ensurePath(rootPath, complete);
      });
      tasks.addTask("ensure src path exists", function(complete) {
        return safefs.ensurePath(docpad.getPath(false, 'source'), complete);
      });
      tasks.addGroup("initialize the website directory files", function() {
        this.setConfig({
          concurrency: 0
        });
        // README
        this.addTask("README.md", function(complete) {
          var data, readmePath;
          readmePath = docpad.getPath(false, 'root', 'README.md');
          data = `# Your [DocPad](https://docpad.bevry.me) Project

## License
Copyright &copy; ${(new Date()).getFullYear()}+ All rights reserved.`;
          return safefs.writeFile(readmePath, data, complete);
        });
        // Config
        this.addTask("docpad.coffee configuration file", function(complete) {
          var configPath, data;
          configPath = docpad.getPath(false, 'root', 'docpad.js');
          data = `// DocPad Configuration File
// https://docpad.bevry.me/config

// Define the DocPad Configuration
const docpadConfig = {
	// ...
}

// Export the DocPad Configuration
module.exports = docpadConfig`;
          return safefs.writeFile(configPath, data, complete);
        });
        // Documents
        this.addTask("documents directory", function(complete) {
          return safefs.ensurePath(docpad.getPath(false, 'document'), complete);
        });
        // Layouts
        this.addTask("layouts directory", function(complete) {
          return safefs.ensurePath(docpad.getPath(false, 'layout'), complete);
        });
        // Files
        return this.addTask("files directory", function(complete) {
          return safefs.ensurePath(docpad.getPath(false, 'file'), complete);
        });
      });
      // Run
      tasks.run();
      return this;
    }

  };

  // =================================
  // Variables

  // ---------------------------------
  // Modules

  // ---------------------------------
  // Base
  /**
   * Events class
   * @property {Object} Events
   */
  DocPad.prototype.Events = Events;

  /**
   * Model class
   * Extension of the Backbone Model class
   * http://backbonejs.org/#Model
   * @property {Object} Model
   */
  DocPad.prototype.Model = Model;

  /**
   * Collection class
   * Extension of the Backbone Collection class
   * http://backbonejs.org/#Collection
   * @property {Object} Collection
   */
  DocPad.prototype.Collection = Collection;

  /**
   * QueryCollection class
   * Extension of the Query Engine QueryCollection class
   * @property {Object} QueryCollection
   */
  DocPad.prototype.QueryCollection = QueryCollection;

  // ---------------------------------
  // Models
  /**
   * File Model class
   * Extension of the Model class
   * @property {Object} FileModel
   */
  DocPad.prototype.FileModel = FileModel;

  /**
   * Document Model class
   * Extension of the File Model class
   * @property {Object} DocumentModel
   */
  DocPad.prototype.DocumentModel = DocumentModel;

  // ---------------------------------
  // Collections
  /**
   * Collection of files in a DocPad project
   * Extension of the QueryCollection class
   * @property {Object} FilesCollection
   */
  DocPad.prototype.FilesCollection = FilesCollection;

  /**
   * Collection of elements in a DocPad project
   * Extension of the Collection class
   * @property {Object} ElementsCollection
   */
  DocPad.prototype.ElementsCollection = ElementsCollection;

  /**
   * Collection of metadata in a DocPad project
   * Extension of the ElementsCollection class
   * @property {Object} MetaCollection
   */
  DocPad.prototype.MetaCollection = MetaCollection;

  /**
   * Collection of JS script files in a DocPad project
   * Extension of the ElementsCollection class
   * @property {Object} ScriptsCollection
   */
  DocPad.prototype.ScriptsCollection = ScriptsCollection;

  /**
   * Collection of CSS style files in a DocPad project
   * Extension of the ElementsCollection class
   * @property {Object} StylesCollection
   */
  DocPad.prototype.StylesCollection = StylesCollection;

  // ---------------------------------
  // DocPad
  /**
   * DocPad's version number
   * @private
   * @property {Number} version
   */
  DocPad.prototype.version = null;

  /**
   * The plugin version requirements
   * @property {String} pluginVersion
   */
  DocPad.prototype.pluginVersion = '2';

  /**
   * Internal property. The caterpillar logger instance bound to DocPad
   * @private
   * @property {Object} loggerInstances
   */
  DocPad.prototype.logger = null;

  /**
   * All the timers that exist within DocPad
   * Used for closing them at shutdown
   * @private
   * @property {Object} timers
   */
  DocPad.prototype.timers = null;

  /**
   * Instance of progress-title
   * @private
   * @property {Progress} progressInstance
   */
  DocPad.prototype.progressInstance = null;

  /**
   * The action runner instance bound to docpad
   * @private
   * @property {Object} actionRunnerInstance
   */
  DocPad.prototype.actionRunnerInstance = null;

  /**
   * Event Listing. String array of event names.
   * Whenever an event is created, it must be applied here to be available to plugins and configuration files
   * Events must be sorted by the order of execution, not for a functional need, but for a documentation need
   * Whenever this array changes, also update: https://docpad.bevry.me/events
   * @private
   * @property {Array} string array of event names
   */
  DocPad.prototype.events = [
    'loadPlugins', // fired each load
    'extendCollections', // fired each load
    'extendTemplateData', // fired each load
    'docpadReady', // fired only once
    'docpadDestroy', // fired once on shutdown
    'consoleSetup', // fired once
    'runBefore',
    'runAfter',
    'generateBefore',
    'populateCollectionsBefore',
    'populateCollections',
    'contextualizeBefore',
    'contextualizeAfter',
    'renderBefore',
    'renderCollectionBefore',
    'render', // fired for each extension conversion
    'renderDocument', // fired for each document render, including layouts and render passes
    'renderCollectionAfter',
    'renderAfter',
    'writeBefore',
    'writeAfter',
    'generateAfter',
    'generated',
    'notify'
  ];

  // ---------------------------------
  // Collections

  // Database collection
  /**
   * QueryEngine collection
   * @private
   * @property {Object} database
   */
  DocPad.prototype.database = null;

  /**
   * Blocks
   * @private
   * @property {Object} blocks
   */
  DocPad.prototype.blocks = null;

  /**
   * The DocPad collections
   * @private
   * @property {Object} collections
   */
  DocPad.prototype.collections = null;

  // ---------------------------------
  // Plugins
  /**
   * Plugins that are loading really slow
   * @property {Object} slowPlugins
   */
  DocPad.prototype.slowPlugins = null; // {}

  /**
   * Loaded plugins indexed by name
   * @property {Object} loadedPlugins
   */
  DocPad.prototype.loadedPlugins = null; // {}

  
  // -----------------------------
  // Paths
  /**
   * The DocPad directory
   * @property {String} corePath
   */
  DocPad.prototype.corePath = pathUtil.resolve(__dirname, '..', '..');

  /**
   * The DocPad library directory
   * @private
   * @property {String} libPath
   */
  DocPad.prototype.libPath = __dirname;

  /**
   * The main DocPad file
   * @property {String} mainPath
   */
  DocPad.prototype.mainPath = pathUtil.resolve(__dirname, 'docpad');

  /**
   * The DocPad package.json path
   * @property {String} packagePath
   */
  DocPad.prototype.packagePath = pathUtil.resolve(__dirname, '..', '..', 'package.json');

  /**
   * The DocPad locale path
   * @property {String} localePath
   */
  DocPad.prototype.localePath = pathUtil.resolve(__dirname, 'locale');

  // -----------------------------
  // Template Data
  /**
   * Description for initialTemplateData
   * @private
   * @property {Object} initialTemplateData
   */
  DocPad.prototype.initialTemplateData = null; // {}

  /**
   * Plugin's Extended Template Data
   * @private
   * @property {Object} pluginsTemplateData
   */
  DocPad.prototype.pluginsTemplateData = null; // {}

  // -----------------------------
  // Locales
  /**
   * Determined locale
   * @private
   * @property {Object} locale
   */
  DocPad.prototype.locale = null;

  // -----------------------------
  // Configuration
  /**
   * Website Package Configuration
   * @private
   * @property {Object} websitePackageConfig
   */
  DocPad.prototype.websitePackageConfig = null; // {}

  /**
   * Merged Configuration
   * Merged in the order of:
   * - initialConfig
   * - userConfig
   * - websiteConfig
   * - instanceConfig
   * - environmentConfig
   * Use getConfig to retrieve this value
   * @private
   * @property {Object} config
   */
  DocPad.prototype.config = null; // {}

  /**
   * Instance Configuration

   * @private
   * @property {Object} instanceConfig
   */
  DocPad.prototype.instanceConfig = null; // {}

  /**
   * Website Configuration
   * Merged into the config property
   * @private
   * @property {Object} websiteConfig
   */
  DocPad.prototype.websiteConfig = null; // {}

  /**
   * User Configuraiton
   * Merged into the config property
   * @private
   * @property {Object} userConfig
   */
  DocPad.prototype.userConfig = null; // {}

  /**
   * Initial Configuration. The default docpadConfig
   * settings that can be overridden in a project's docpad.coffee file.
   * Merged into the config property
   * @private
   * @property {Object} initialConfig
   */
  DocPad.prototype.initialConfig = {
    // -----------------------------
    // Plugins

    // Whether or not we should use the global docpad instance
    global: false,
    // Configuration to pass to any plugins pluginName: pluginConfiguration
    plugins: {},
    // -----------------------------
    // Project Paths

    // The project directory
    rootPath: process.cwd(),
    // The project's package.json path
    packagePath: 'package.json',
    // The project's configuration paths
    // Reads only the first one that exists
    // If you want to read multiple configuration paths, then point it to a coffee|js file that requires
    // the other paths you want and exports the merged config
    configPaths: ['docpad.js', 'docpad.coffee', 'docpad.json', 'docpad.cson'],
    // Plugin directories to load
    pluginPaths: [],
    // Paths that we should watch for reload changes in
    reloadPaths: [],
    // Paths that we should watch for regeneration changes in
    regeneratePaths: [],
    // The DocPad debug log path (docpad-debug.log)
    debugLogPath: 'docpad-debug.log',
    // The User's configuration path (.docpad.cson)
    userConfigPath: '.docpad.cson',
    // -----------------------------
    // Project Options

    // The project's out directory
    outPath: 'out',
    // The project's source directory
    sourcePaths: ['source', 'src'],
    // The project's documents directories
    // relative to the source path
    documentsPaths: ['documents', 'render'],
    // The project's files directories
    // relative to the source path
    filesPaths: ['files', 'static', 'public'],
    // The project's layouts directory
    // relative to the source path
    layoutsPaths: ['layouts'],
    // Ignored file patterns during directory parsing
    ignorePaths: false,
    ignoreHiddenFiles: false,
    ignoreCommonPatterns: true,
    ignoreCustomPatterns: false,
    // Watch options
    watchOptions: null,
    // -----------------------------
    // Logging

    // Log Level
    // Which level of logging should we actually output
    logLevel: 6,
    // Verbose
    // Set log level to 7
    verbose: false,
    // Debug
    // Output all log messages to the debugLogPath
    debug: false,
    // Color
    // Whether or not our terminal output should have color
    // `null` will default to what the terminal supports
    color: docpadUtil.isTTY(),
    // Silent
    // Will set the following
    // logLevel = 3
    // progress = welcome = false
    silent: false,
    // Progress
    // Whether or not we should display the progress in the terminal title bar
    progress: true,
    // -----------------------------
    // Other

    // Catch our own exceptions (error events on the DocPad instance)
    // use "error"/truthy to report
    // use "fatal" to report and exit
    catchOurExceptions: 'error',
    // Catch any uncaught exception
    // use "error" to report
    // use "fatal"/truthy to report and exit
    catchUncaughtExceptions: 'fatal',
    // Whether or not DocPad is allowed to set the exit code on fatal errors
    // May only work on node v0.11.8 and above
    setExitCodeOnFatal: true,
    // Whether or not DocPad is allowed to set the exit code on standard errors
    // May only work on node v0.11.8 and above
    setExitCodeOnError: true,
    // Whether or not DocPad is allowed to set the exit code when some code has requested to
    // May only work on node v0.11.8 and above
    setExitCodeOnRequest: true,
    // The time to wait before cancelling a request
    requestTimeout: 30 * 1000,
    // The time to wait when destroying DocPad
    destroyDelay: -1,
    // Whether or not to destroy on exit
    destroyOnExit: true,
    // Whether or not to destroy on signal interrupt (ctrl+c)
    destroyOnSignalInterrupt: true,
    // The time to wait after a source file has changed before using it to regenerate
    regenerateDelay: 100,
    // The time to wait before outputting the files we are waiting on
    slowFilesDelay: 20 * 1000,
    // The time to wait before outputting the plugins we are waiting on
    slowPluginsDelay: 20 * 1000,
    // Utilise the database cache
    databaseCache: false, // [false, true, 'write']
    
    // Detect Encoding
    // Should we attempt to auto detect the encoding of our files?
    // Useful when you are using foreign encoding (e.g. GBK) for your files
    detectEncoding: false,
    // Render Single Extensions
    // Whether or not we should render single extensions by default
    renderSingleExtensions: false,
    // Render Passes
    // How many times should we render documents that reference other documents?
    renderPasses: 1,
    // Powered By DocPad
    // Whether or not we should include DocPad in the Powered-By meta header
    // Please leave this enabled as it is a standard practice and promotes DocPad in the web eco-system
    poweredByDocPad: true,
    // Template Data
    // What data would you like to expose to your templates
    templateData: {},
    // Collections
    // A hash of functions that create collections
    collections: {},
    // Events
    // A hash of event handlers
    events: {},
    // Regenerate Every
    // Performs a regenerate every x milliseconds, useful for always having the latest data
    regenerateEvery: false,
    // Regerenate Every Options
    // The generate options to use on the regenerate every call
    regenerateEveryOptions: {
      populate: true,
      partial: false
    },
    // -----------------------------
    // Environment Configuration

    // Locale Code
    // The code we shall use for our locale (e.g. en, fr, etc)
    localeCode: null,
    // Environment
    // Whether or not we are in production or development
    // Separate environments using a comma or a space
    env: null,
    // Environments
    // Environment specific configuration to over-ride the global configuration
    environments: {
      development: {
        // Only do these if we are running standalone (aka not included in a module)
        welcome: isUser,
        progress: isUser
      }
    }
  };

  /**
   * Has DocPad commenced destruction?
   */
  DocPad.prototype.destroying = false;

  // ---------------------------------
  // Generate

  // Generate Helpers
  /**
   * Has DocPad's generation process started?
   * @private
   * @property {Boolean} generateStarted
   */
  DocPad.prototype.generateStarted = null;

  /**
   * Has DocPad's generation process ended?
   * @private
   * @property {Boolean} generateEnded
   */
  DocPad.prototype.generateEnded = null;

  /**
   * Is DocPad currently generating?
   * @private
   * @property {Boolean} generating
   */
  DocPad.prototype.generating = false;

  /**
   * Has DocPad done at least one generation?
   * True once the first generation has occured.
   * @private
   * @property {Object} generated
   */
  DocPad.prototype.generated = false;

  // ---------------------------------
  // Watch
  /**
   * Array of file watchers
   * @private
   * @property {Array} watchers
   */
  DocPad.prototype.watchers = null;

  return DocPad;

}).call(this);

// ---------------------------------
// Export
module.exports = DocPad;
