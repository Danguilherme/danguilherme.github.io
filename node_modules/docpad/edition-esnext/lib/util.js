// Generated by CoffeeScript 2.5.1
  // =====================================
  // Requires

// Standard Library
var Errlop, compact, docpadUtil, extendr, extractOptsAndCallback, inquirer, pathUtil, uniq, util,
  indexOf = [].indexOf;

pathUtil = require('path');

util = require('util');

// External
Errlop = require('errlop').default;

({uniq, compact} = require('underscore'));

extractOptsAndCallback = require('extract-opts');

inquirer = require('inquirer');

extendr = require('extendr');

// =====================================
// Export
/**
 * The DocPad Util Class.
 * Collection of DocPad utility methods
 * @class docpadUtil
 * @constructor
 * @static
 */
module.exports = docpadUtil = {
  /**
   * Create a new Buffer, with support for Node <4
   * @private
   * @method newBuffer
   * @param {*} data
   * @return {Buffer}
   */
  newBuffer: function(data) {
    if (Buffer.from != null) {
      return Buffer.from(data);
    } else {
      return new Buffer(data);
    }
  },
  /**
   * Write to stderr
   * @private
   * @method writeStderr
   * @param {String} data
   */
  writeStderr: function(data) {
    var err;
    try {
      return process.stderr.write(data);
    } catch (error) {
      err = error;
      // ignore the error, try stdout instead
      return process.stdout.write(data);
    }
  },
  /**
   * Get Default Log Level
   * @private
   * @method getDefaultLogLevel
   * @return {Number} default log level
   */
  getTestingLogLevel: function() {
    if (docpadUtil.isTravis() || (indexOf.call(process.argv, '-d') >= 0)) {
      return 7;
    } else {
      return 5;
    }
  },
  /**
   * Are we executing on Travis
   * @private
   * @method isTravis
   * @return {String} The travis node version
   */
  isTravis: function() {
    return process.env.TRAVIS_NODE_VERSION != null;
  },
  /**
   * Is this TTY
   * @private
   * @method isTTY
   * @return {Boolean}
   */
  isTTY: function() {
    var ref, ref1;
    return ((ref = process.stdout) != null ? ref.isTTY : void 0) === true && ((ref1 = process.stderr) != null ? ref1.isTTY : void 0) === true;
  },
  /**
   * Is Standadlone
   * @private
   * @method isStandalone
   * @return {Object}
   */
  isStandalone: function() {
    return /docpad$/.test(process.argv[1] || '');
  },
  /**
   * Is user
   * @private
   * @method isUser
   * @return {Boolean}
   */
  isUser: function() {
    return docpadUtil.isStandalone() && docpadUtil.isTTY() && docpadUtil.isTravis() === false;
  },
  /**
   * Are we using standard encoding?
   * @private
   * @method isStandardEncoding
   * @param {String} encoding
   * @return {Boolean}
   */
  isStandardEncoding: function(encoding) {
    var ref;
    return (ref = encoding.toLowerCase()) === 'ascii' || ref === 'utf8' || ref === 'utf-8';
  },
  /**
   * Get Local DocPad Installation Executable - ie
   * not the global installation
   * @private
   * @method getLocalDocPadExecutable
   * @return {String} the path to the local DocPad executable
   */
  getLocalDocPadExecutable: function() {
    return pathUtil.join(process.cwd(), 'node_modules', 'docpad', 'bin', 'docpad');
  },
  /**
   * Is Local DocPad Installation
   * @private
   * @method isLocalDocPadExecutable
   * @return {Boolean}
   */
  isLocalDocPadExecutable: function() {
    var ref;
    return ref = docpadUtil.getLocalDocPadExecutable(), indexOf.call(process.argv, ref) >= 0;
  },
  /**
   * Does the local DocPad Installation Exist?
   * @private
   * @method getLocalDocPadExecutableExistance
   * @return {Boolean}
   */
  getLocalDocPadExecutableExistance: function() {
    return require('safefs').existsSync(docpadUtil.getLocalDocPadExecutable()) === true;
  },
  /**
   * Spawn Local DocPad Executable
   * @private
   * @method startLocalDocPadExecutable
   * @param {Function} next
   * @return {Object} don't know what
   */
  startLocalDocPadExecutable: function(next) {
    var args, command;
    args = process.argv.slice(2);
    command = ['node', docpadUtil.getLocalDocPadExecutable()].concat(args);
    return require('safeps').spawn(command, {
      stdio: 'inherit'
    }, function(err) {
      var message;
      if (err) {
        if (next) {
          return next(err);
        } else {
          message = 'An error occured within the child DocPad instance: ' + err.message + '\n';
          return docpadUtil.writeStderr(message);
        }
      } else {
        return typeof next === "function" ? next() : void 0;
      }
    });
  },
  /**
   * get a filename without the extension
   * @method getBasename
   * @param {String} filename
   * @return {String} base name
   */
  getBasename: function(filename) {
    var basename;
    if (filename[0] === '.') {
      basename = filename.replace(/^(\.[^\.]+)\..*$/, '$1');
    } else {
      basename = filename.replace(/\..*$/, '');
    }
    return basename;
  },
  /**
   * Get the extensions of a filename
   * @method getExtensions
   * @param {String} filename
   * @return {Array} array of string
   */
  getExtensions: function(filename) {
    var extensions;
    extensions = filename.split(/\./g).slice(1);
    return extensions;
  },
  /**
   * Get the extension from a bunch of extensions
   * @method getExtension
   * @param {Array} extensions
   * @return {String} the extension
   */
  getExtension: function(extensions) {
    var extension;
    if (!require('typechecker').isArray(extensions)) {
      extensions = docpadUtil.getExtensions(extensions);
    }
    if (extensions.length !== 0) {
      extension = extensions.slice(-1)[0] || null;
    } else {
      extension = null;
    }
    return extension;
  },
  /**
   * Get the directory path.
   * Wrapper around the node.js path.dirname method
   * @method getDirPath
   * @param {String} path
   * @return {String}
   */
  getDirPath: function(path) {
    return pathUtil.dirname(path) || '';
  },
  /**
   * Get the file name.
   * Wrapper around the node.js path.basename method
   * @method getFilename
   * @param {String} path
   * @return {String}
   */
  getFilename: function(path) {
    return pathUtil.basename(path);
  },
  /**
   * Get the DocPad out file name
   * @method getOutFilename
   * @param {String} basename
   * @param {String} extension
   * @return {String}
   */
  getOutFilename: function(basename, extension) {
    if (basename === '.' + extension) { // prevent: .htaccess.htaccess
      return basename;
    } else {
      return basename + (extension ? '.' + extension : '');
    }
  },
  /**
   * Get the URL
   * @method getUrl
   * @param {String} relativePath
   * @return {String}
   */
  getUrl: function(relativePath) {
    return '/' + relativePath.replace(/[\\]/g, '/');
  },
  /**
   * Get the post slug from the URL
   * @method getSlug
   * @param {String} relativeBase
   * @return {String} the slug
   */
  getSlug: function(relativeBase) {
    return require('bal-util').generateSlugSync(relativeBase);
  },
  /**
   * Get the user to select one of the choices
   * @method choose
   * @param {string} message
   * @param {Array<string>} choices
   * @param {Object} [opts={}]
   * @param {Function} next
   */
  choose: function(message, choices, opts = {}, next) {
    var question;
    // Question
    question = extendr.extend({
      name: 'question',
      type: 'list',
      message,
      choices
    }, opts);
    // Ask
    inquirer.prompt([question]).catch(next).then(function(answers) {
      return next(null, answers.question);
    });
    return this;
  },
  /**
   * Perform an action
   * next(err,...), ... = any special arguments from the action
   * this should be it's own npm module
   * as we also use the concept of actions in a few other packages.
   * Important concept in DocPad.
   * @method action
   * @param {Object} action
   * @param {Object} opts
   * @param {Function} next
   */
  action: function(action, opts, next) {
    var actionMethod, actionTaskOrGroup, actions, err, i, len, locale, me, missingError, ref, ref1, run, runner, runnerTask, task;
    // Prepare
    [opts, next] = extractOptsAndCallback(opts, next);
    me = this;
    locale = me.getLocale();
    run = (ref = opts.run) != null ? ref : true;
    runner = (ref1 = opts.runner) != null ? ref1 : me.getActionRunner();
    // Array?
    if (Array.isArray(action)) {
      actions = action;
    } else {
      actions = action.split(/[,\s]+/g);
    }
    // Clean actions
    actions = uniq(compact(actions));
    // Exit if we have no actions
    if (actions.length === 0) {
      err = new Errlop(locale.actionEmpty);
      return next(err);
      me;
    }
    // We have multiple actions
    if (actions.length > 1) {
      actionTaskOrGroup = runner.createTaskGroup('actions bundle: ' + actions.join(' '));
      for (i = 0, len = actions.length; i < len; i++) {
        action = actions[i];
        try {
          // Fetch
          actionMethod = me[action].bind(me);
        } catch (error) {
          missingError = error;
          err = new Errlop(util.format(locale.actionNonexistant, action), missingError);
          return next(err);
          me;
        }
        // Task
        task = actionTaskOrGroup.createTask(action, actionMethod, {
          args: [opts]
        });
        actionTaskOrGroup.addTask(task);
      }
    } else {
      // Fetch the action
      // We have single actions
      action = actions[0];
      try {
        // Fetch
        actionMethod = me[action].bind(me);
      } catch (error) {
        missingError = error;
        err = new Errlop(util.format(locale.actionNonexistant, action), missingError);
        return next(err);
        me;
      }
      // Task
      actionTaskOrGroup = runner.createTask(action, actionMethod, {
        args: [opts]
      });
    }
    // Create our runner task
    runnerTask = runner.createTask(`runner task for action: ${action}`, function(continueWithRunner) {
      // Add our listener for our action
      actionTaskOrGroup.done(function(...args) {
        // If we have a completion callback, let it handle the error
        if (next) {
          next(...args);
          args = args.slice();
          args[0] = null;
        }
        // Continue with our runner
        return continueWithRunner(...args);
      });
      // Run our action
      return actionTaskOrGroup.run();
    });
    // Add it and run it
    runner.addTask(runnerTask);
    if (run === true) {
      runner.run();
    }
    // Chain
    return me;
  }
};
