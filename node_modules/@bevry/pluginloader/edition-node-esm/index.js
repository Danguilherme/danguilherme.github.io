// Import
import { resolve } from 'path'
import Errlop from 'errlop'
import { satisfies } from 'semver'
import { isClass } from 'typechecker'
// Local
const alphanumeric = /^[a-z0-9]+$/
/** Check the specified versions against the specified ranges */
function checkVersions(versions, ranges, group) {
	const errors = []
	if (ranges) {
		for (const thing in versions) {
			if (versions.hasOwnProperty(thing)) {
				// the .replace is to support version flags, such as -beta
				const version = String(versions[thing]).replace(/-.+/, '')
				const range = ranges[thing]
				if (range && satisfies(version, range) === false) {
					errors.push(
						new Errlop(
							`${group} [${thing} = ${range}] unsupported by plugin's range [${range}]`
						)
					)
				}
			}
		}
	}
	return errors
}
/** The Plugin Loader class */
export default class PluginLoader {
	constructor(opts) {
		this.log = opts.log || function () {}
		this.keyword = opts.keyword
		this.prefix = opts.prefix
		this.versions = opts.versions || {}
		this.BasePlugin = opts.BasePlugin
		this.pluginPath = opts.pluginPath
		// load
		if (!opts.packageData) {
			if (this.pluginPath) {
				this.packageData = require(resolve(this.pluginPath, 'package.json'))
			} else {
				throw new Errlop(
					"Either the plugin's package data or the plugin's path must be specified."
				)
			}
		} else {
			this.packageData = opts.packageData
		}
		// validate
		if (!this.packageData.name) {
			throw new Errlop(
				'The plugin\'s package data must include a "name" field.'
			)
		}
		// ensure
		if (!this.packageData.keywords) this.packageData.keywords = []
		if (!this.packageData.platforms) this.packageData.platforms = []
		if (!this.packageData.engines) this.packageData.engines = {}
		if (!this.packageData.peerDependencies)
			this.packageData.peerDependencies = {}
		// apply
		this.pluginName = this.packageData.name
		// validate
		if (this.prefix) {
			// .startsWith is only available node >= 0.12
			if (this.pluginName.indexOf(this.prefix) === 0) {
				this.pluginName = this.pluginName.substr(this.prefix.length)
			} else {
				throw new Errlop(
					`The plugin's name of [${this.pluginName}] must begin with the prefix [${this.prefix}].`
				)
			}
		}
		if (alphanumeric.test(this.pluginName) === false) {
			throw new Errlop(
				`The plugin's name of [${this.pluginName}] must be alphanumeric to avoid common naming problems.`
			)
		}
		/**
		 * The Plugin Class.
		 * If not specified, then it is resolved by requiring {@link PluginLoader#pluginPath}.
		 * @type {BasePlugin}
		 */
		this.PluginClass = this.resolve(
			opts.PluginClass || require(this.pluginPath)
		)
		// Validate
		this.validate()
	}
	/**
	 * Alternative means for creating a {@link PluginLoader} instance.
	 */
	static create(opts) {
		return new this(opts)
	}
	/**
	 * Resolve the input as the plugin class
	 * @throws {Errlop} resolve failure reason
	 */
	resolve(direct) {
		if (isClass(direct)) {
			// module.exports = class MyPlugin extends require('...-baseplugin') {}
			this.log('debug', `The plugin [${this.pluginPath}] was resolved directly`)
			return direct
		} else {
			// module.exports = (BasePlugin) -> class MyPlugin extends BasePlugin {}
			let indirect
			try {
				indirect = direct(this.BasePlugin)
			} catch (err) {
				if (
					/Class constructor \w+ cannot be invoked without 'new'/.test(
						err.message
					)
				) {
					// for some reason, isClass(direct) returned `false`, this should not happen
					this.log(
						'warn',
						this.error(
							'pluginloader encountered a direct result that had a false negative with class detection\n' +
								'everything will work fine, but this should be fixed by the plugin author\n' +
								'the direct result in question is:\n' +
								direct.toString()
						)
					)
					this.log(
						'debug',
						`The plugin [${this.pluginPath}] was resolved directly, via false negative fallback`
					)
					return direct
				} else {
					throw this.error(
						'The indirect resolution of the PluginClass failed.',
						err
					)
				}
			}
			if (isClass(indirect)) {
				this.log(
					'debug',
					`The plugin [${this.pluginPath}] was resolved indirectly`
				)
				return indirect
			} else {
				throw this.error(
					'The resolved PluginClass was not detectable as a class.'
				)
			}
		}
	}
	/**
	 * Check if this plugin is supported
	 * @returns supported
	 * @throws {Errlop} supported failure reason
	 */
	validate() {
		const { keywords, platforms, engines, peerDependencies } = this.packageData
		const errors = []
		if (this.keyword && keywords.includes(this.keyword) === false) {
			errors.push(
				new Errlop(
					`keyword [${
						this.keyword
					}] missing from the plugin's keywords [${keywords.join(', ')}]`
				)
			)
		}
		if (platforms.length && platforms.includes(process.platform) === false) {
			errors.push(
				new Errlop(
					`platform [${
						process.platform
					}] unsupported by plugin's engines [${platforms.join(', ')}]`
				)
			)
		}
		if (engines) {
			// @ts-ignore
			errors.push(...checkVersions(process.versions, engines, 'engine'))
		}
		if (peerDependencies) {
			errors.push(
				...checkVersions(this.versions, peerDependencies, 'peer dependency')
			)
		}
		if (errors.length) {
			throw new Errlop(
				`Plugin [${this.pluginPath}] is unsupported.`,
				errors.length === 1
					? errors[0]
					: new Errlop(errors.map((error) => error.stack).join('\n'))
			)
		}
		return true
	}
	/** Helper for creating Errlop instances against the plugin. */
	error(message, parent) {
		return new Errlop(
			`${message}\nPlugin: ${this.pluginPath || this.pluginName}`,
			parent
		)
	}
	/**
	 * Instantiate the {@link PluginLoader#PluginClass} with the arguments.
	 * @param {...*} arguments to forward to the plugin class constructor
	 * @returns {BasePlugin} the instantiation result
	 * @throws {Errlop} instantiation failure reason
	 */
	create(...args) {
		// prepare
		const { PluginClass } = this
		try {
			// create the plugin
			// @ts-ignore
			const plugin = new PluginClass(...args)
			// ensure name is correct if specified
			if (plugin.name && plugin.name !== this.pluginName) {
				throw new Error(
					`The plugin instance's "name" of [${plugin.name}] must match the specified name of [${this.pluginName}].`
				)
			}
			// return the plugin
			return plugin
		} catch (err) {
			throw new Errlop(
				`Plugin [${this.pluginPath || this.pluginName}] failed to instantiate.`,
				err
			)
		}
	}
}
